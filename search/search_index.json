{"config":{"indexing":"full","lang":["en","de"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction What is this? This document attempts to provide guidelines for multiple programming languages. Of course, if you create such a document you should practice what you preach. So rest assured, these guidelines are representative to what I do in my day-to-day work. Notice that not all guidelines have a clear rationale. Some of them are simply choices I have made. In the end, it doesn't matter what choice you made, as long as you make one and apply it consistently. Why would you use this document? Although some might see coding guidelines as undesired overhead or something that limits creativity, this approach has already proven its value for many years. This is because not every developer: is aware that code is generally read 10 times more than it is changed. is aware of the potential pitfalls in one programming language, which are a good way in other. is aware of the impact of using (or neglecting to use) particular solutions on aspects like security, performance, multi-language support, etc. realizes that not every developer is as capable, skilled or experienced to understand elegant, but potentially very abstract solutions. Basics Even if this document covers many scenarios, it will not cover every possible scenario. But Unlike what some (junior) developers believe, just because something is not explicitly listed as bad, it does not mean that using it is okay. There is a set of rules than can be applied to all situations, regardless of their context. The include the following: Principle of least astonishment (a.k.a. POLA) : you should choose solution that everyone can understand, and that keeps them on the right track. Keep it simple, stupid (a.k.a. KISS) : the simplest solution is more than sufficient. You aren't gonna need it (a.k.a. YAGIN) : create a solution for the problem at hand, not for the ones you think may happen later on. Can you predict the future? Don't repeat yourself (a.k.a. DRY) : avoid duplication within a component, a source control repository or a bounded context , without forgetting the Rule of Three heuristic. The four principles of object-oriented programming : encapsulation, abstraction, inheritance and polymorphism. In general, generated code should not need to comply with coding guidelines. However, if it is possible to modify the templates used for generation, try to make them generate code that complies as much as possible. Regardless of the elegance of someone's solution, if it's too complex for the ordinary developer, exposes unusual behavior, or tries to solve many possible future issues, it es very likely the wrong solution and needs redesign. The worst response a developer can give yo to these principles is: \"But it works!\". Wie fange ich an? Ask all developers to carefully read this document at least once. This will give them a sense of the kind of guidelines the document containes. Make sure evereybody agrees with the rules. Create a project checklist with the most important rules and use this checklist for your Peer Review . Consider forking the original source and create your own internal version of the document. Use tools, e. g. IDEs, compiler plugins or build tools, to be able to comply with these guidelines. THe most IDEs have a intelligent code instpection engine, with some configuration, already supporting many aspects of the Coding Guidelines. Inspiration This document is inspired by C# Coding Guidelines . In the last years I often created some kind of code styles and coding guidelines, which I used in both, private and professional projects. Now I would like to use this knowledge to write some general guidelines. Is this a official coding standard? Definitely not! This document does not state that projects must comply with these guidelines, neither does it say which guidelines are more important than other. It is intended to be a guide for anyone who does not want to deal with creating own rules but still wants to have a homogeneous developer experience within one team, but also across multiple teams. However, to help with decisions about which rules may be important, I have added a recommendation level to each rule: Guidelines that you should never skip and should be applicable to all situations. Strongly recommended guidelines May not be applicable in all situations","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#what-is-this","text":"This document attempts to provide guidelines for multiple programming languages. Of course, if you create such a document you should practice what you preach. So rest assured, these guidelines are representative to what I do in my day-to-day work. Notice that not all guidelines have a clear rationale. Some of them are simply choices I have made. In the end, it doesn't matter what choice you made, as long as you make one and apply it consistently.","title":"What is this?"},{"location":"#why-would-you-use-this-document","text":"Although some might see coding guidelines as undesired overhead or something that limits creativity, this approach has already proven its value for many years. This is because not every developer: is aware that code is generally read 10 times more than it is changed. is aware of the potential pitfalls in one programming language, which are a good way in other. is aware of the impact of using (or neglecting to use) particular solutions on aspects like security, performance, multi-language support, etc. realizes that not every developer is as capable, skilled or experienced to understand elegant, but potentially very abstract solutions.","title":"Why would you use this document?"},{"location":"#basics","text":"Even if this document covers many scenarios, it will not cover every possible scenario. But Unlike what some (junior) developers believe, just because something is not explicitly listed as bad, it does not mean that using it is okay. There is a set of rules than can be applied to all situations, regardless of their context. The include the following: Principle of least astonishment (a.k.a. POLA) : you should choose solution that everyone can understand, and that keeps them on the right track. Keep it simple, stupid (a.k.a. KISS) : the simplest solution is more than sufficient. You aren't gonna need it (a.k.a. YAGIN) : create a solution for the problem at hand, not for the ones you think may happen later on. Can you predict the future? Don't repeat yourself (a.k.a. DRY) : avoid duplication within a component, a source control repository or a bounded context , without forgetting the Rule of Three heuristic. The four principles of object-oriented programming : encapsulation, abstraction, inheritance and polymorphism. In general, generated code should not need to comply with coding guidelines. However, if it is possible to modify the templates used for generation, try to make them generate code that complies as much as possible. Regardless of the elegance of someone's solution, if it's too complex for the ordinary developer, exposes unusual behavior, or tries to solve many possible future issues, it es very likely the wrong solution and needs redesign. The worst response a developer can give yo to these principles is: \"But it works!\".","title":"Basics"},{"location":"#wie-fange-ich-an","text":"Ask all developers to carefully read this document at least once. This will give them a sense of the kind of guidelines the document containes. Make sure evereybody agrees with the rules. Create a project checklist with the most important rules and use this checklist for your Peer Review . Consider forking the original source and create your own internal version of the document. Use tools, e. g. IDEs, compiler plugins or build tools, to be able to comply with these guidelines. THe most IDEs have a intelligent code instpection engine, with some configuration, already supporting many aspects of the Coding Guidelines.","title":"Wie fange ich an?"},{"location":"#inspiration","text":"This document is inspired by C# Coding Guidelines . In the last years I often created some kind of code styles and coding guidelines, which I used in both, private and professional projects. Now I would like to use this knowledge to write some general guidelines.","title":"Inspiration"},{"location":"#is-this-a-official-coding-standard","text":"Definitely not! This document does not state that projects must comply with these guidelines, neither does it say which guidelines are more important than other. It is intended to be a guide for anyone who does not want to deal with creating own rules but still wants to have a homogeneous developer experience within one team, but also across multiple teams. However, to help with decisions about which rules may be important, I have added a recommendation level to each rule: Guidelines that you should never skip and should be applicable to all situations. Strongly recommended guidelines May not be applicable in all situations","title":"Is this a official coding standard?"},{"location":"guidelines/general/11000/","text":"en Translation coming soon Version Control System (VCS) Immer ein VCS nutzen (GCG11001) Es sollte f\u00fcr jedes Projekt, auch f\u00fcr sehr kleine Skripte, eine VCS genutzt werden. Bei Projekten, die von mehr als einer Person genutzt werden, sollte das Projekt auf einem Remoteserver hinterlegt sein. Die Verwendung eines VCS erlaubt es einen, auf eine sehr einfache und sichere Art und Weise, alle \u00c4nderungen nachvollziehen zu k\u00f6nnen und ungewollte \u00c4nderungen wieder r\u00fcckg\u00e4ngig zu machen. Definieren eines Workflow / einer Branching-Strategie (GCG11002) Damit jeder wei\u00df, wie mit dem verwendeten VCS zu arbeiten ist, sollte im Vorfeld ein Workflow bzw. eine Branching-Strategie definiert werden, die zu dem jeweiligen Projekt passt. Eine Branching-Strategie umfasst die Fragen Wie werden Branches benannt? Wann und wie wird ein neuer Branch erstellt? Wann und wie wird ein Branch gemerged? Wie lange leben Branches? Wie werden \u00fcber das Branching die Versionen abgebildet? Wie bei (fast) jedem Thema in der Softwareentwicklung sollte man nicht das Rad neu erfinden, sondern sich erstmal bestehende L\u00f6sungen anschauen. F\u00fcr das VCS git haben bereits viele schlaue K\u00f6pfe sich Gedanken gemacht und u. A. die Workflows Gitflow , GitLab Flow und GitHub flow entwickelt. Diese k\u00f6nnen entweder direkt \u00fcbernommen werden, oder f\u00fcr die eigene Situation angepasst und kombiniert werden. Peer Review (GCG11003) Bevor \u00c4nderungen produktiv genutzt werden, sollte mindestens eine zweite Person diese \u00fcberpr\u00fcfen. Damit kann der Code sowohl technisch als auch fachlich gepr\u00fcft werden, um die Qualit\u00e4t der \u00c4nderung sicherzustellen. Der perfekte Moment um \u00c4nderungen zu hinterfragen, Alternativen vorzuschlagen und m\u00f6gliche Fehler fr\u00fchzeitig zu erkennen.","title":"Version Control"},{"location":"guidelines/general/11000/#version-control-system-vcs","text":"","title":"Version Control System (VCS)"},{"location":"guidelines/general/11000/#immer-ein-vcs-nutzen-gcg11001","text":"Es sollte f\u00fcr jedes Projekt, auch f\u00fcr sehr kleine Skripte, eine VCS genutzt werden. Bei Projekten, die von mehr als einer Person genutzt werden, sollte das Projekt auf einem Remoteserver hinterlegt sein. Die Verwendung eines VCS erlaubt es einen, auf eine sehr einfache und sichere Art und Weise, alle \u00c4nderungen nachvollziehen zu k\u00f6nnen und ungewollte \u00c4nderungen wieder r\u00fcckg\u00e4ngig zu machen.","title":"Immer ein VCS nutzen (GCG11001) "},{"location":"guidelines/general/11000/#definieren-eines-workflow-einer-branching-strategie-gcg11002","text":"Damit jeder wei\u00df, wie mit dem verwendeten VCS zu arbeiten ist, sollte im Vorfeld ein Workflow bzw. eine Branching-Strategie definiert werden, die zu dem jeweiligen Projekt passt. Eine Branching-Strategie umfasst die Fragen Wie werden Branches benannt? Wann und wie wird ein neuer Branch erstellt? Wann und wie wird ein Branch gemerged? Wie lange leben Branches? Wie werden \u00fcber das Branching die Versionen abgebildet? Wie bei (fast) jedem Thema in der Softwareentwicklung sollte man nicht das Rad neu erfinden, sondern sich erstmal bestehende L\u00f6sungen anschauen. F\u00fcr das VCS git haben bereits viele schlaue K\u00f6pfe sich Gedanken gemacht und u. A. die Workflows Gitflow , GitLab Flow und GitHub flow entwickelt. Diese k\u00f6nnen entweder direkt \u00fcbernommen werden, oder f\u00fcr die eigene Situation angepasst und kombiniert werden.","title":"Definieren eines Workflow / einer Branching-Strategie (GCG11002) "},{"location":"guidelines/general/11000/#peer-review-gcg11003","text":"Bevor \u00c4nderungen produktiv genutzt werden, sollte mindestens eine zweite Person diese \u00fcberpr\u00fcfen. Damit kann der Code sowohl technisch als auch fachlich gepr\u00fcft werden, um die Qualit\u00e4t der \u00c4nderung sicherzustellen. Der perfekte Moment um \u00c4nderungen zu hinterfragen, Alternativen vorzuschlagen und m\u00f6gliche Fehler fr\u00fchzeitig zu erkennen.","title":"Peer Review (GCG11003) "},{"location":"guidelines/general/12000/","text":"Update Policy Fix security vulnerabilities (GCG12001) Security vulnerabilities, both self-produced and these that come in through dependencies, should be fixed as soon as possible. Keep your dependencies up to date (GCG12002) You should update your dependencies to avoid the situation that you miss bug fixes or security updates, because the currently used version is no longer supported or maintained. It's much easier to update a recent version to the latest than a deprecated version. Use LTS versions if possible. Define a version support policy (GCG12003) If other people (both customers and colleagues) depends on the software it makes sense to define how long each version will be supported and will receive updates. You could also define a policy for backward compatibility. Maintaining a changelog (GCG12004) You should maintain a changelog to make it easier for users and contributors to see precisely what notable changes have been made between each version of the project. Use a VCS to keep track of code changes (see GCG11001 ). Software Versioning (GCG12004) A clear and documented version schema helps users and contributors to see the importance of an update. Furthermore, the version can mark releases, pre-releases, test version etc.","title":"Update Policy"},{"location":"guidelines/general/12000/#update-policy","text":"","title":"Update Policy"},{"location":"guidelines/general/12000/#fix-security-vulnerabilities-gcg12001","text":"Security vulnerabilities, both self-produced and these that come in through dependencies, should be fixed as soon as possible.","title":"Fix security vulnerabilities (GCG12001) "},{"location":"guidelines/general/12000/#keep-your-dependencies-up-to-date-gcg12002","text":"You should update your dependencies to avoid the situation that you miss bug fixes or security updates, because the currently used version is no longer supported or maintained. It's much easier to update a recent version to the latest than a deprecated version. Use LTS versions if possible.","title":"Keep your dependencies up to date (GCG12002) "},{"location":"guidelines/general/12000/#define-a-version-support-policy-gcg12003","text":"If other people (both customers and colleagues) depends on the software it makes sense to define how long each version will be supported and will receive updates. You could also define a policy for backward compatibility.","title":"Define a version support policy (GCG12003) "},{"location":"guidelines/general/12000/#maintaining-a-changelog-gcg12004","text":"You should maintain a changelog to make it easier for users and contributors to see precisely what notable changes have been made between each version of the project. Use a VCS to keep track of code changes (see GCG11001 ).","title":"Maintaining a changelog (GCG12004) "},{"location":"guidelines/general/12000/#software-versioning-gcg12004","text":"A clear and documented version schema helps users and contributors to see the importance of an update. Furthermore, the version can mark releases, pre-releases, test version etc.","title":"Software Versioning (GCG12004) "},{"location":"guidelines/general/13000/","text":"en Translation coming soon Tools und Automatismen Know the basics (GCG13001) Wenn Tools \u00fcber eine Oberfl\u00e4che genutzt werden, dann sollten die dahinterstehenden Prozesse und Mechanismen in den Grundz\u00fcgen bekannt sein. Jeder sollte f\u00e4hig sein, die Tools, die t\u00e4glich genutzt werden, auch ohne oder mit einer anderen Oberfl\u00e4che, sicher zu verwenden. Genauso sollte m\u00f6gliche Probleme und Limitierungen erkannt und verstanden werden k\u00f6nnen. Nutz den (f\u00fcr Dich) passenden Editor (GCG13002) Du solltet den Editor, unabh\u00e4ngig davon, ob es eine vollwertige IDE oder ein Texteditor f\u00fcr die Konsole ist, nutzen, mit dem du am besten arbeiten kannst. Ein solches Tool sollte die Produktivit\u00e4t steigern und zu dem Workload passen. Es kann sein, dass ein Umfeld (Programmiersprache, Arbeitgeber usw.) bestimmte Tools voraussetzt. Diese sollten dann so eingerichtet werden, dass sie die eigenen Anspr\u00fcche erf\u00fcllen und nicht die von Kollegen \u2013 man selbst arbeitet \u00fcberwiegen damit, nicht der Kollege oder die Kollegin. Dazu z\u00e4hlen Shortcuts, Highlighting, Appearance and Behavior, Automatismen etc. Verwendung von CI/CD-Systemen (GCG13003) CI/CD -Systeme k\u00f6nnen alle Schritte (Bauen, Testen, Packen, Verteilen etc.) nach der eigentlichen Entwicklung automatisieren. Diese Tools beschleunigen diese Prozesse und verhindern Fehler. Im besten Fall wird die CI/CD-Pipeline automatisch mit dem Ver\u00f6ffentlichen einer \u00c4nderung ausgel\u00f6st. Ebenfalls k\u00f6nnen Tools zur \u00dcberpr\u00fcfung der Codequalit\u00e4t teil der CI/CD-Pipeline sein. Test- und Produktivversionen d\u00fcrfen nicht lokal gebaut werden (GCG13004) Um sicherzustellen, dass jeder Build reproduzierbar ist, d\u00fcrfen Test- und Produktivversionen nicht lokal gebaut werden, sondern, am besten automatisiert, nur auf einem Buildserver. Dies beschleunigt den Prozess und sorgt f\u00fcr eine erh\u00f6hte Integrit\u00e4t und Konsistenz der Build-Artefakte. Verwendung von Tools zur steigerung der Codequalit\u00e4t (GCG13005) Es gibt diverse M\u00f6glichkeiten, um die Codequalit\u00e4t pr\u00fcfen zu lassen. Die zwei, die am einfachsten zu realisieren sind, sind automatisierte Tests (besonders Unittests) und die Verwendung von Tools zur statischen Codeanalyse. Um Verbesserungen nachweisen zu k\u00f6nnen, sollten entsprechende Metriken gesammelt werden. Das Definieren eines Codestyles oder von Codingguidelienes kann genauso ein Werkzeug darstellen.","title":"Tools and Automation"},{"location":"guidelines/general/13000/#tools-und-automatismen","text":"","title":"Tools und Automatismen"},{"location":"guidelines/general/13000/#know-the-basics-gcg13001","text":"Wenn Tools \u00fcber eine Oberfl\u00e4che genutzt werden, dann sollten die dahinterstehenden Prozesse und Mechanismen in den Grundz\u00fcgen bekannt sein. Jeder sollte f\u00e4hig sein, die Tools, die t\u00e4glich genutzt werden, auch ohne oder mit einer anderen Oberfl\u00e4che, sicher zu verwenden. Genauso sollte m\u00f6gliche Probleme und Limitierungen erkannt und verstanden werden k\u00f6nnen.","title":"Know the basics (GCG13001) "},{"location":"guidelines/general/13000/#nutz-den-fur-dich-passenden-editor-gcg13002","text":"Du solltet den Editor, unabh\u00e4ngig davon, ob es eine vollwertige IDE oder ein Texteditor f\u00fcr die Konsole ist, nutzen, mit dem du am besten arbeiten kannst. Ein solches Tool sollte die Produktivit\u00e4t steigern und zu dem Workload passen. Es kann sein, dass ein Umfeld (Programmiersprache, Arbeitgeber usw.) bestimmte Tools voraussetzt. Diese sollten dann so eingerichtet werden, dass sie die eigenen Anspr\u00fcche erf\u00fcllen und nicht die von Kollegen \u2013 man selbst arbeitet \u00fcberwiegen damit, nicht der Kollege oder die Kollegin. Dazu z\u00e4hlen Shortcuts, Highlighting, Appearance and Behavior, Automatismen etc.","title":"Nutz den (f\u00fcr Dich) passenden Editor (GCG13002) "},{"location":"guidelines/general/13000/#verwendung-von-cicd-systemen-gcg13003","text":"CI/CD -Systeme k\u00f6nnen alle Schritte (Bauen, Testen, Packen, Verteilen etc.) nach der eigentlichen Entwicklung automatisieren. Diese Tools beschleunigen diese Prozesse und verhindern Fehler. Im besten Fall wird die CI/CD-Pipeline automatisch mit dem Ver\u00f6ffentlichen einer \u00c4nderung ausgel\u00f6st. Ebenfalls k\u00f6nnen Tools zur \u00dcberpr\u00fcfung der Codequalit\u00e4t teil der CI/CD-Pipeline sein.","title":"Verwendung von CI/CD-Systemen (GCG13003) "},{"location":"guidelines/general/13000/#test-und-produktivversionen-durfen-nicht-lokal-gebaut-werden-gcg13004","text":"Um sicherzustellen, dass jeder Build reproduzierbar ist, d\u00fcrfen Test- und Produktivversionen nicht lokal gebaut werden, sondern, am besten automatisiert, nur auf einem Buildserver. Dies beschleunigt den Prozess und sorgt f\u00fcr eine erh\u00f6hte Integrit\u00e4t und Konsistenz der Build-Artefakte.","title":"Test- und Produktivversionen d\u00fcrfen nicht lokal gebaut werden (GCG13004) "},{"location":"guidelines/general/13000/#verwendung-von-tools-zur-steigerung-der-codequalitat-gcg13005","text":"Es gibt diverse M\u00f6glichkeiten, um die Codequalit\u00e4t pr\u00fcfen zu lassen. Die zwei, die am einfachsten zu realisieren sind, sind automatisierte Tests (besonders Unittests) und die Verwendung von Tools zur statischen Codeanalyse. Um Verbesserungen nachweisen zu k\u00f6nnen, sollten entsprechende Metriken gesammelt werden. Das Definieren eines Codestyles oder von Codingguidelienes kann genauso ein Werkzeug darstellen.","title":"Verwendung von Tools zur steigerung der Codequalit\u00e4t (GCG13005) "},{"location":"guidelines/general/14000/","text":"Naming convention Use US English (GCG14001) All identifiers (Types, member, parameters, variables etc.) should be named using words from the US English language. Names should be easily readble, preferably grammatically correct names. Example: HorizontalAlginment is better than AlignmentHorizontal . Favor readability over brevity. Example: CanScrollHorizontally is better than CanScrollHorizontally . Avoid using names that conflicts with keywords from widely spread used programming languages. Use proper notation for language elements (GCG14002) Depanding on the used programming language the proper notation for language elements such as classes, method and variables should be used. Widely spread casings are camel case, pascal case, snake case and kebab case . Don't include numbers in varfianles, parameters and type members (GCG14003) In most cases these kind of names are lazy excuses for not defining a clear and intention-revealing name. Often they are used instead of collections. Don't use prefixes (GCG14004) Types, type members, parameters, variables etc. shouldn't include a prefix to define the scope or type. Known prefixes are g_ for global , s_ for static or string , i_ for integer and _ for private members. In some programming languages it is not possible to obey this rule. Many languages uses _ for backing fields, other to communicate that a member is private. Don't use abbreviations (GCG14005) Abbreviations like btn for button and cmd for command harm the readability and intelligibility. Avoid single character variable names, such as i or q . Use index or query . Exception: Use well-known acronyms and abbreviations that are widely accepted or well-known in your work domain. For instance, use acronym UI instead of UserInterface and abbreviation Id instead of Identity . Name members, parameters and variables according to their meaning and not their type (GCG14006) The name should describe the functionality and not their type. Identifiers that refer to a collection type should have plural names. Name types using nouns, noun phrases or adjective phrases (GCG14007) Naming Example noun IComponent noun phrase ICustomAttributeProvider adjective phrase IPersistable Name methods using verbs or verb-object pairs (GCG14008) Naming Example verb Show verb-object pair ShowDialog The name should describe the what , and if possible, the why . Name generic type parameters with descriptive names (GCG14009) Always prefix type parameters with the letter T for Type . The name should describe the what . Name members similarly to other members in the used programming language or framework (GCG14010) To let developers, who are already familiar with the used programming language or framework, finding their way into your project, you should use a naming pattern which is widely used by the language or framework. Avoid short names or names that can be mistaken for other names (GCG14011) Although technically correct, statements like the following can be confusing: bool b001 = (lo == l0) ? (I1 == 11) : (lOl != 101); Don't repeat the name of a class or enumeration in its members (GCG14013) class Employee { // Wrong! static GetEmployee() {...} DeleteEmployee() {...} // Right static Get() {...} Delete() {...} // Also correct. AddNewJob() {...} RegisterForMeeting() {...} } Avoid class containing terms like Utility and Helper (GCG14013) Class containing terms like Utility or Helper are usually static classes and are introduced without considering object-oriented principles. Avoid method names containing the word and (GCG14014) A methods containing the word and implies, that it is doing more than one thing, which violates the Single Responsibility Principle . Pr\u00e4fixen von booleschen Variablen und Member (GCG14015) Prefixing of boolean variables and members (GCG14015) To make boolean variables and members more descriptive consider prefixing them with Is , Has , Can , Allows or Supports .","title":"Namming Conventions"},{"location":"guidelines/general/14000/#naming-convention","text":"","title":"Naming convention"},{"location":"guidelines/general/14000/#use-us-english-gcg14001","text":"All identifiers (Types, member, parameters, variables etc.) should be named using words from the US English language. Names should be easily readble, preferably grammatically correct names. Example: HorizontalAlginment is better than AlignmentHorizontal . Favor readability over brevity. Example: CanScrollHorizontally is better than CanScrollHorizontally . Avoid using names that conflicts with keywords from widely spread used programming languages.","title":"Use US English (GCG14001) "},{"location":"guidelines/general/14000/#use-proper-notation-for-language-elements-gcg14002","text":"Depanding on the used programming language the proper notation for language elements such as classes, method and variables should be used. Widely spread casings are camel case, pascal case, snake case and kebab case .","title":"Use proper notation for language elements (GCG14002) "},{"location":"guidelines/general/14000/#dont-include-numbers-in-varfianles-parameters-and-type-members-gcg14003","text":"In most cases these kind of names are lazy excuses for not defining a clear and intention-revealing name. Often they are used instead of collections.","title":"Don't include numbers in varfianles, parameters and type members (GCG14003) "},{"location":"guidelines/general/14000/#dont-use-prefixes-gcg14004","text":"Types, type members, parameters, variables etc. shouldn't include a prefix to define the scope or type. Known prefixes are g_ for global , s_ for static or string , i_ for integer and _ for private members. In some programming languages it is not possible to obey this rule. Many languages uses _ for backing fields, other to communicate that a member is private.","title":"Don't use prefixes (GCG14004) "},{"location":"guidelines/general/14000/#dont-use-abbreviations-gcg14005","text":"Abbreviations like btn for button and cmd for command harm the readability and intelligibility. Avoid single character variable names, such as i or q . Use index or query . Exception: Use well-known acronyms and abbreviations that are widely accepted or well-known in your work domain. For instance, use acronym UI instead of UserInterface and abbreviation Id instead of Identity .","title":"Don't use abbreviations (GCG14005) "},{"location":"guidelines/general/14000/#name-members-parameters-and-variables-according-to-their-meaning-and-not-their-type-gcg14006","text":"The name should describe the functionality and not their type. Identifiers that refer to a collection type should have plural names.","title":"Name members, parameters and variables according to their meaning and not their type (GCG14006) "},{"location":"guidelines/general/14000/#name-types-using-nouns-noun-phrases-or-adjective-phrases-gcg14007","text":"Naming Example noun IComponent noun phrase ICustomAttributeProvider adjective phrase IPersistable","title":"Name types using nouns, noun phrases or adjective phrases (GCG14007) "},{"location":"guidelines/general/14000/#name-methods-using-verbs-or-verb-object-pairs-gcg14008","text":"Naming Example verb Show verb-object pair ShowDialog The name should describe the what , and if possible, the why .","title":"Name methods using verbs or verb-object pairs (GCG14008) "},{"location":"guidelines/general/14000/#name-generic-type-parameters-with-descriptive-names-gcg14009","text":"Always prefix type parameters with the letter T for Type . The name should describe the what .","title":"Name generic type parameters with descriptive names (GCG14009) "},{"location":"guidelines/general/14000/#name-members-similarly-to-other-members-in-the-used-programming-language-or-framework-gcg14010","text":"To let developers, who are already familiar with the used programming language or framework, finding their way into your project, you should use a naming pattern which is widely used by the language or framework.","title":"Name members similarly to other members in the used programming language or framework (GCG14010) "},{"location":"guidelines/general/14000/#avoid-short-names-or-names-that-can-be-mistaken-for-other-names-gcg14011","text":"Although technically correct, statements like the following can be confusing: bool b001 = (lo == l0) ? (I1 == 11) : (lOl != 101);","title":"Avoid short names or names that can be mistaken for other names (GCG14011) "},{"location":"guidelines/general/14000/#dont-repeat-the-name-of-a-class-or-enumeration-in-its-members-gcg14013","text":"class Employee { // Wrong! static GetEmployee() {...} DeleteEmployee() {...} // Right static Get() {...} Delete() {...} // Also correct. AddNewJob() {...} RegisterForMeeting() {...} }","title":"Don't repeat the name of a class or enumeration in its members (GCG14013) "},{"location":"guidelines/general/14000/#avoid-class-containing-terms-like-utility-and-helper-gcg14013","text":"Class containing terms like Utility or Helper are usually static classes and are introduced without considering object-oriented principles.","title":"Avoid class containing terms like Utility and Helper (GCG14013) "},{"location":"guidelines/general/14000/#avoid-method-names-containing-the-word-and-gcg14014","text":"A methods containing the word and implies, that it is doing more than one thing, which violates the Single Responsibility Principle .","title":"Avoid method names containing the word and (GCG14014) "},{"location":"guidelines/general/14000/#prafixen-von-booleschen-variablen-und-member-gcg14015","text":"","title":"Pr\u00e4fixen von booleschen Variablen und Member (GCG14015) "},{"location":"guidelines/general/14000/#prefixing-of-boolean-variables-and-members-gcg14015","text":"To make boolean variables and members more descriptive consider prefixing them with Is , Has , Can , Allows or Supports .","title":"Prefixing of boolean variables and members (GCG14015) "},{"location":"guidelines/general/15000/","text":"en Translation coming soon Maintainability Eine Methode sollte nicht mehr als 7 Statements haben (GCG15001) Eine Methode mit mehr als sieben Statements macht zu viel oder verst\u00f6\u00dft gegen das Single Responsibility Principle . Au\u00dferdem wird es mit jedem Statement aufw\u00e4ndiger zu verstehen, was der Code machen soll. Eine Methode mit mehr Statements sollte entsprechend in mehrere kleine Methoden, die einen selbsterkl\u00e4renden Namen haben, runtergebrochen werden. Der High-Level Algorithmus muss allerdings weiterhin verst\u00e4ndlich sein. Eine Ausnahme hierbei k\u00f6nnen Tests, Builder oder Methoden, die den Anwendungsfluss steuern sein. Es sollte dennoch gepr\u00fcft werden, ob die Anzahl der Statements pro Methode durch Pattern oder verschachtelte Pr\u00fcfungen reduziert werden k\u00f6nnen, wodurch die Verst\u00e4ndlichkeit und Wartbarkeit gesteigert werden kann. So geschlossen wie m\u00f6glich, so offen wie n\u00f6tig (GCG15002) Alle Typen und Member sollten standardm\u00e4\u00dfig nur von denen gesehen und genutzt werden k\u00f6nnen, die auf diese Typen und Member direkt zugreifen m\u00fcssen. Entsprechend sollten Member standardm\u00e4\u00dfig private und Typen internal sein. Au\u00dferdem sollten standardm\u00e4\u00dfig weder Member noch Typen \u00fcberschrieben oder beerbt werden k\u00f6nnen. Nur f\u00fcr den Fall, dass von Au\u00dfen auf einen Typen oder dessen Member zugegriffen werden muss, sollte die Sichtbarkeit langsam erh\u00f6ht werden. Vermeidung von Ausdr\u00fccken mit doppelter Negierung (GCG15003) In manchen F\u00e4llen ist es sinnvoll, oder gegeben, dass eine Variable bzw. ein Typen-Member den Negativfall abdeckt, allerdings sollte es vermieden werden, diese in einer negierten Bedingung zu verwenden. bool hasOrders = !customer.HasNoOrders; Doppelte Verneinungen sind schwerer zu verstehen und werden oft \u00fcberlesen. Ein Typ, eine Datei (GCG15004) Eine Source-Datei sollte genau einen Typen enthalten, bzw. einen Zweck dienen. Die Datei sollte auch nach diesem Typen benannt sein. Ausnahme: Nested-Types sollten Teil der Datei des \u00fcbergeordneten Typen sein. Ausnahme: Typen, die sich nur durch die Anzahl an generischen Typ-Parametern unterscheiden, sollten Teil der gleichen Datei sein. Don't use magic numbers (GCG15005) Vermeide die Verwendung von Literal Values, sowohl Zahlen als auch Strings. Stattdessen sollten Konstanten verwendet werden. Ausgenommen sind Strings f\u00fcr das Logging, sowie Werte, die durch ihren Context eindeutig sind und zuk\u00fcnftig nicht ge\u00e4ndert werden. mean = (a + b) / 2; // okay WaitMilliseconds(waitTimeInSeconds * 1000); // clear enough Anmerkung: Enum-Typen eigenen sich oft f\u00fcr Konstanten genutzt werden. Explizit, statt Implizit (GCG15006) Die Deklarierung sollte immer so explizit wie m\u00f6glich sein. Variablen sollten so sp\u00e4t wie m\u00f6glich deklariert und initialisiert werden (GCG15007) Variablen sollten zu dem Zeitpunkt deklariert und initialisiert werden, an dem sie gebraucht werden. Deklariere und Weise immer nur eine Variable pro Zeile zu (GCG15008) Vermeide Ausdr\u00fccke wie var result = otherVariable = GetSomeValue(); Keine explizite Vergleiche auf True und False (GCG15009) if (condition == false) // wrong; bad style if (condition != true) // also wrong if (((condition == true) == true) == true) // where do you stop? if (condition) // OK Ver\u00e4ndere nicht die Loop-Variable innerhalb eines for -Loops (GCG15010) Das Updaten der Loop-Variablen innerhalb des Loops f\u00fcr in aller Regel zu Verwirrung, besonders, wenn sie an mehr als einer Stelle ver\u00e4ndert wird. for (int index = 0; index < 10; index++) { if (someCondition) { index = 11; // Wrong! Use 'break' or 'continue' instead. } } Vermeide verschachtelte Loops (GCG15011) Methoden mit verschachtelten Loops ist schwerer zu verstehen, als eine Methode mit nur einem Loop. Werden verschachtelte Loops ben\u00f6tigt, sollten diese durch andere Mittel ersetzt werden, oder in mehrere Methoden aufgeteilt werden. F\u00fcge immer den default -Block nach dem letzten case in einem switch -Statement hinzu (GCG15012) Wenn der default -Block leer gelassen werden soll, dann f\u00fcge ein aussagekr\u00e4ftiges Kommentar hinzu. Wenn der Block nicht erreicht werden darf, dann wird eine Exception, um zuk\u00fcnftige \u00c4nderungen zu erkennen, die bisher nicht erwartet werden. Beende jedes if - else - if -Statement mit einem else -Statement (GCG15013) Verwende den letzten else -Block f\u00fcr das Standardverhalten. Wenn dieser Block nicht erreicht werden kann oder darf, dann wird eine Exception. Verwende ein einfaches Conditional Assignment Statement, statt einem if - else -Konstrukt (GCG15013) // rather than: bool isPositive; if (value > 0) { isPositive = true; } else { isPositive = false; } // write: bool isPositive = (value > 0); Verwende switch -Statements, statt if - else -Statement (GCG15014) In vielen F\u00e4llen kann ein switch -Statement ein if - else -Statement abl\u00f6sen und es dadurch verst\u00e4ndlicher und wartbarer gestalten. Vermeide Signaturen mit mehr als 3 Parametern (GCG15015) Um Konstruktoren, Methoden, Funktionen etc. klein und fokussiert zu halten, muss die Anzahl der Parameter gering gehalten werden. Es empfiehlt sich, die Anzahl auf drei Parameter zu beschr\u00e4nken. Konstruktoren, zum Erstellen von Typen, die mehrere Parameter erwarten, k\u00f6nnen z. B. durch das Builder-Pattern vereinfacht werden. Generell gilt, desto weniger Parameter, umso einfacher und verst\u00e4ndlicher ist die Methode. Au\u00dferdem resultiert das Testen von Methoden, die viele Parameter erwarten, in vielen Szenarien, die abgedeckt werden m\u00fcssen. Vermeide Signaturen, die einen bool -Parameter haben (GCG15016) Folgendes Beispiel: public Customer CreateCustomer(bool hasPlatinumLevel) {} Auf den ersten Blick wirkt die Signatur verst\u00e4ndlich, aber sobald die Methode verwendet wird, geht die Verst\u00e4ndlichkeit verloren: Customer customer = CreateCustomer(true); Oft macht eine Methode, die einen Boolean erwartet mehr als eine Sache. Eine Alternative ist es, den Boolean mit einer Enumeration zu ersetzen. Kommentiere niemals Code aus (GCG15017) Ver\u00f6ffentliche niemals eine \u00c4nderung, in der Code auskommentiert ist. Niemand wird wissen, weshalb der Code auskommentiert ist. Wurde es tempor\u00e4r zum Testen entfernt? Ist es ein kopiertes Beispiel? Kann der Code gel\u00f6scht werden? Schreib code, der leicht zu debuggen ist (GCG15018) Vermeide es, zu viele Statements innerhalb einer einzigen Zeile zu schreiben. Dadurch k\u00f6nnen Debugger effektiver genutzt werden. \u00dcberladungen sollten sich gegenseitig aufrufen (GCG15019) Diese Regel betrifft nur \u00dcberladungen, die optionale Parameter bereitstellen. public string ToString() { return ToString(Format.Default); } public string ToString(Format format) { return ToString(format, Culture.Default); } public string ToString(Format format, Culture culture) { // return result } Lagere komplexe Ausdr\u00fccke in separaten Methoden aus (GCG15020) Komplexe Ausdr\u00fccke, z. B. Bedingungen, sollten in Methoden mit eindeutigen Namen ausgelagert werden, damit diese verst\u00e4ndlicher werden.","title":"Maintainability"},{"location":"guidelines/general/15000/#maintainability","text":"","title":"Maintainability"},{"location":"guidelines/general/15000/#eine-methode-sollte-nicht-mehr-als-7-statements-haben-gcg15001","text":"Eine Methode mit mehr als sieben Statements macht zu viel oder verst\u00f6\u00dft gegen das Single Responsibility Principle . Au\u00dferdem wird es mit jedem Statement aufw\u00e4ndiger zu verstehen, was der Code machen soll. Eine Methode mit mehr Statements sollte entsprechend in mehrere kleine Methoden, die einen selbsterkl\u00e4renden Namen haben, runtergebrochen werden. Der High-Level Algorithmus muss allerdings weiterhin verst\u00e4ndlich sein. Eine Ausnahme hierbei k\u00f6nnen Tests, Builder oder Methoden, die den Anwendungsfluss steuern sein. Es sollte dennoch gepr\u00fcft werden, ob die Anzahl der Statements pro Methode durch Pattern oder verschachtelte Pr\u00fcfungen reduziert werden k\u00f6nnen, wodurch die Verst\u00e4ndlichkeit und Wartbarkeit gesteigert werden kann.","title":"Eine Methode sollte nicht mehr als 7 Statements haben (GCG15001) "},{"location":"guidelines/general/15000/#so-geschlossen-wie-moglich-so-offen-wie-notig-gcg15002","text":"Alle Typen und Member sollten standardm\u00e4\u00dfig nur von denen gesehen und genutzt werden k\u00f6nnen, die auf diese Typen und Member direkt zugreifen m\u00fcssen. Entsprechend sollten Member standardm\u00e4\u00dfig private und Typen internal sein. Au\u00dferdem sollten standardm\u00e4\u00dfig weder Member noch Typen \u00fcberschrieben oder beerbt werden k\u00f6nnen. Nur f\u00fcr den Fall, dass von Au\u00dfen auf einen Typen oder dessen Member zugegriffen werden muss, sollte die Sichtbarkeit langsam erh\u00f6ht werden.","title":"So geschlossen wie m\u00f6glich, so offen wie n\u00f6tig (GCG15002) "},{"location":"guidelines/general/15000/#vermeidung-von-ausdrucken-mit-doppelter-negierung-gcg15003","text":"In manchen F\u00e4llen ist es sinnvoll, oder gegeben, dass eine Variable bzw. ein Typen-Member den Negativfall abdeckt, allerdings sollte es vermieden werden, diese in einer negierten Bedingung zu verwenden. bool hasOrders = !customer.HasNoOrders; Doppelte Verneinungen sind schwerer zu verstehen und werden oft \u00fcberlesen.","title":"Vermeidung von Ausdr\u00fccken mit doppelter Negierung (GCG15003) "},{"location":"guidelines/general/15000/#ein-typ-eine-datei-gcg15004","text":"Eine Source-Datei sollte genau einen Typen enthalten, bzw. einen Zweck dienen. Die Datei sollte auch nach diesem Typen benannt sein. Ausnahme: Nested-Types sollten Teil der Datei des \u00fcbergeordneten Typen sein. Ausnahme: Typen, die sich nur durch die Anzahl an generischen Typ-Parametern unterscheiden, sollten Teil der gleichen Datei sein.","title":"Ein Typ, eine Datei (GCG15004) "},{"location":"guidelines/general/15000/#dont-use-magic-numbers-gcg15005","text":"Vermeide die Verwendung von Literal Values, sowohl Zahlen als auch Strings. Stattdessen sollten Konstanten verwendet werden. Ausgenommen sind Strings f\u00fcr das Logging, sowie Werte, die durch ihren Context eindeutig sind und zuk\u00fcnftig nicht ge\u00e4ndert werden. mean = (a + b) / 2; // okay WaitMilliseconds(waitTimeInSeconds * 1000); // clear enough Anmerkung: Enum-Typen eigenen sich oft f\u00fcr Konstanten genutzt werden.","title":"Don't use magic numbers (GCG15005) "},{"location":"guidelines/general/15000/#explizit-statt-implizit-gcg15006","text":"Die Deklarierung sollte immer so explizit wie m\u00f6glich sein.","title":"Explizit, statt Implizit (GCG15006) "},{"location":"guidelines/general/15000/#variablen-sollten-so-spat-wie-moglich-deklariert-und-initialisiert-werden-gcg15007","text":"Variablen sollten zu dem Zeitpunkt deklariert und initialisiert werden, an dem sie gebraucht werden.","title":"Variablen sollten so sp\u00e4t wie m\u00f6glich deklariert und initialisiert werden (GCG15007) "},{"location":"guidelines/general/15000/#deklariere-und-weise-immer-nur-eine-variable-pro-zeile-zu-gcg15008","text":"Vermeide Ausdr\u00fccke wie var result = otherVariable = GetSomeValue();","title":"Deklariere und Weise immer nur eine Variable pro Zeile zu (GCG15008) "},{"location":"guidelines/general/15000/#keine-explizite-vergleiche-auf-true-und-false-gcg15009","text":"if (condition == false) // wrong; bad style if (condition != true) // also wrong if (((condition == true) == true) == true) // where do you stop? if (condition) // OK","title":"Keine explizite Vergleiche auf True und False (GCG15009) "},{"location":"guidelines/general/15000/#verandere-nicht-die-loop-variable-innerhalb-eines-for-loops-gcg15010","text":"Das Updaten der Loop-Variablen innerhalb des Loops f\u00fcr in aller Regel zu Verwirrung, besonders, wenn sie an mehr als einer Stelle ver\u00e4ndert wird. for (int index = 0; index < 10; index++) { if (someCondition) { index = 11; // Wrong! Use 'break' or 'continue' instead. } }","title":"Ver\u00e4ndere nicht die Loop-Variable innerhalb eines for-Loops (GCG15010) "},{"location":"guidelines/general/15000/#vermeide-verschachtelte-loops-gcg15011","text":"Methoden mit verschachtelten Loops ist schwerer zu verstehen, als eine Methode mit nur einem Loop. Werden verschachtelte Loops ben\u00f6tigt, sollten diese durch andere Mittel ersetzt werden, oder in mehrere Methoden aufgeteilt werden.","title":"Vermeide verschachtelte Loops (GCG15011) "},{"location":"guidelines/general/15000/#fuge-immer-den-default-block-nach-dem-letzten-case-in-einem-switch-statement-hinzu-gcg15012","text":"Wenn der default -Block leer gelassen werden soll, dann f\u00fcge ein aussagekr\u00e4ftiges Kommentar hinzu. Wenn der Block nicht erreicht werden darf, dann wird eine Exception, um zuk\u00fcnftige \u00c4nderungen zu erkennen, die bisher nicht erwartet werden.","title":"F\u00fcge immer den default-Block nach dem letzten case in einem switch-Statement hinzu (GCG15012) "},{"location":"guidelines/general/15000/#beende-jedes-if-else-if-statement-mit-einem-else-statement-gcg15013","text":"Verwende den letzten else -Block f\u00fcr das Standardverhalten. Wenn dieser Block nicht erreicht werden kann oder darf, dann wird eine Exception.","title":"Beende jedes if-else-if-Statement mit einem else-Statement (GCG15013) "},{"location":"guidelines/general/15000/#verwende-ein-einfaches-conditional-assignment-statement-statt-einem-if-else-konstrukt-gcg15013","text":"// rather than: bool isPositive; if (value > 0) { isPositive = true; } else { isPositive = false; } // write: bool isPositive = (value > 0);","title":"Verwende ein einfaches Conditional Assignment Statement, statt einem if-else-Konstrukt (GCG15013) "},{"location":"guidelines/general/15000/#verwende-switch-statements-statt-if-else-statement-gcg15014","text":"In vielen F\u00e4llen kann ein switch -Statement ein if - else -Statement abl\u00f6sen und es dadurch verst\u00e4ndlicher und wartbarer gestalten.","title":"Verwende switch-Statements, statt if-else-Statement (GCG15014) "},{"location":"guidelines/general/15000/#vermeide-signaturen-mit-mehr-als-3-parametern-gcg15015","text":"Um Konstruktoren, Methoden, Funktionen etc. klein und fokussiert zu halten, muss die Anzahl der Parameter gering gehalten werden. Es empfiehlt sich, die Anzahl auf drei Parameter zu beschr\u00e4nken. Konstruktoren, zum Erstellen von Typen, die mehrere Parameter erwarten, k\u00f6nnen z. B. durch das Builder-Pattern vereinfacht werden. Generell gilt, desto weniger Parameter, umso einfacher und verst\u00e4ndlicher ist die Methode. Au\u00dferdem resultiert das Testen von Methoden, die viele Parameter erwarten, in vielen Szenarien, die abgedeckt werden m\u00fcssen.","title":"Vermeide Signaturen mit mehr als 3 Parametern (GCG15015) "},{"location":"guidelines/general/15000/#vermeide-signaturen-die-einen-bool-parameter-haben-gcg15016","text":"Folgendes Beispiel: public Customer CreateCustomer(bool hasPlatinumLevel) {} Auf den ersten Blick wirkt die Signatur verst\u00e4ndlich, aber sobald die Methode verwendet wird, geht die Verst\u00e4ndlichkeit verloren: Customer customer = CreateCustomer(true); Oft macht eine Methode, die einen Boolean erwartet mehr als eine Sache. Eine Alternative ist es, den Boolean mit einer Enumeration zu ersetzen.","title":"Vermeide Signaturen, die einen bool-Parameter haben (GCG15016) "},{"location":"guidelines/general/15000/#kommentiere-niemals-code-aus-gcg15017","text":"Ver\u00f6ffentliche niemals eine \u00c4nderung, in der Code auskommentiert ist. Niemand wird wissen, weshalb der Code auskommentiert ist. Wurde es tempor\u00e4r zum Testen entfernt? Ist es ein kopiertes Beispiel? Kann der Code gel\u00f6scht werden?","title":"Kommentiere niemals Code aus (GCG15017) "},{"location":"guidelines/general/15000/#schreib-code-der-leicht-zu-debuggen-ist-gcg15018","text":"Vermeide es, zu viele Statements innerhalb einer einzigen Zeile zu schreiben. Dadurch k\u00f6nnen Debugger effektiver genutzt werden.","title":"Schreib code, der leicht zu debuggen ist (GCG15018) "},{"location":"guidelines/general/15000/#uberladungen-sollten-sich-gegenseitig-aufrufen-gcg15019","text":"Diese Regel betrifft nur \u00dcberladungen, die optionale Parameter bereitstellen. public string ToString() { return ToString(Format.Default); } public string ToString(Format format) { return ToString(format, Culture.Default); } public string ToString(Format format, Culture culture) { // return result }","title":"\u00dcberladungen sollten sich gegenseitig aufrufen (GCG15019) "},{"location":"guidelines/general/15000/#lagere-komplexe-ausdrucke-in-separaten-methoden-aus-gcg15020","text":"Komplexe Ausdr\u00fccke, z. B. Bedingungen, sollten in Methoden mit eindeutigen Namen ausgelagert werden, damit diese verst\u00e4ndlicher werden.","title":"Lagere komplexe Ausdr\u00fccke in separaten Methoden aus (GCG15020) "},{"location":"guidelines/general/16000/","text":"Documentation Write comments in US English (CGC16001) Write code documentation in US English (CGC16002) Dokumentiere alle von au\u00dferhalb verf\u00fcgbaren Typen und Members (CGC16003) Documenting all types and members, which are accessible from outside (assembly, namespace, class, \u2026). Use the common way to document that kind of code, depending on your programming language (javadoc for java, XMLDoc for .Net and so on). This way other developers can get the most out of your function without knowing the concrete implementation. Furthermore, you can use tools to create professionally looking documentation. Write documentation with other in mind (CGC16004) Write the documentation with other in mind. Assume they will not have access to the full source, the requirements and specifications, so try to explain how to get the most of the functionality of your code. Avoid inline comments (CGC16005) If you feel the need to explain a block of code using a comment, consider replacing that block with a method with a clear name. Don't use comments for tracking work to be done later (CGC16006) Annotating a block of code or some work to be done using a TODO or similar comment may seem a reasonable way of tracking work-to-be-done. In reality, nobody really searches for comments like that. Use a project management system to keep track of leftovers. Another way is a combination of the usage of a work item in a project management system, and a related TODO comment, with a reference to that work item. Only write comments to explain complex algorithms or decisions (CGC16007) Try to focus comments on the why and what of a code block and not the how . Avoid explaining the statements in words, but instead help the reader understand why you chose a certain solution or algorithm and what you are trying to achieve. If applicable, also mention that you chose an alternative solution because you ran into a problem with the obvious solution.","title":"Documentation"},{"location":"guidelines/general/16000/#documentation","text":"","title":"Documentation"},{"location":"guidelines/general/16000/#write-comments-in-us-english-cgc16001","text":"","title":"Write comments in US English (CGC16001) "},{"location":"guidelines/general/16000/#write-code-documentation-in-us-english-cgc16002","text":"","title":"Write code documentation in US English (CGC16002) "},{"location":"guidelines/general/16000/#dokumentiere-alle-von-auerhalb-verfugbaren-typen-und-members-cgc16003","text":"Documenting all types and members, which are accessible from outside (assembly, namespace, class, \u2026). Use the common way to document that kind of code, depending on your programming language (javadoc for java, XMLDoc for .Net and so on). This way other developers can get the most out of your function without knowing the concrete implementation. Furthermore, you can use tools to create professionally looking documentation.","title":"Dokumentiere alle von au\u00dferhalb verf\u00fcgbaren Typen und Members (CGC16003) "},{"location":"guidelines/general/16000/#write-documentation-with-other-in-mind-cgc16004","text":"Write the documentation with other in mind. Assume they will not have access to the full source, the requirements and specifications, so try to explain how to get the most of the functionality of your code.","title":"Write documentation with other in mind (CGC16004) "},{"location":"guidelines/general/16000/#avoid-inline-comments-cgc16005","text":"If you feel the need to explain a block of code using a comment, consider replacing that block with a method with a clear name.","title":"Avoid inline comments (CGC16005) "},{"location":"guidelines/general/16000/#dont-use-comments-for-tracking-work-to-be-done-later-cgc16006","text":"Annotating a block of code or some work to be done using a TODO or similar comment may seem a reasonable way of tracking work-to-be-done. In reality, nobody really searches for comments like that. Use a project management system to keep track of leftovers. Another way is a combination of the usage of a work item in a project management system, and a related TODO comment, with a reference to that work item.","title":"Don't use comments for tracking work to be done later (CGC16006) "},{"location":"guidelines/general/16000/#only-write-comments-to-explain-complex-algorithms-or-decisions-cgc16007","text":"Try to focus comments on the why and what of a code block and not the how . Avoid explaining the statements in words, but instead help the reader understand why you chose a certain solution or algorithm and what you are trying to achieve. If applicable, also mention that you chose an alternative solution because you ran into a problem with the obvious solution.","title":"Only write comments to explain complex algorithms or decisions (CGC16007) "},{"location":"guidelines/general/17000/","text":"Logging Always use a logging framework (GCG17001) Always use a well-established logging framework. They contain all necessary features. Additionally, they have been tested in practice and only contains a few bugs. Exception: Small application, interactive console applications and scripts whose output does not need to be tracked, do not require a logging framework. Define the usage of log levels (GCG17002) Suggestion: Log level Description Importance Trace The most fine-grained information only used in rare cases where you need the full visibility of what is happening in your application. Can be used to annotate each step in a complex algorithm. Can be ignored during normal operations. A log level describing events showing step by step. Debug Less granular compared to Trace , but it is more than you will need in everyday use. Should be used for information that may be needed for diagnosis issues and troubleshooting or when running application in the test environment for purpose of making sure everything is running correctly Can be ignored during normal operations. A log level used for events considered to be useful during software debugging. Info The standard log level indicating that something happened, the application entered a certain state, etc. This log level should be purely informative and not looking into them on a regular basis shouldn't result in missing any important information. Can be ignored during normal operations. An event happened, the event is purely informative. Warn The log level that indicates that something unexpected happened in the application, a problem, or a situation that might disturb one of the processes. That doesn't mean that the application failed. Should be used in situations that are unexpected, but the code can continue the work. Unexpected behavior happened inside the application, but it is continuing its work, and the key business features are operating as expected. Error The log level that should be used when the application hits an issue preventing one or more functionalities from properly functioning. One or more functionalities are not working, preventing some functionalities from working correctly. Fatal, Critical The log level that tells that the application encountered an event or entered a state in which one of the crucial business functionality is no longer working. May be used when the application is not able to connect to a crucial data store. Often the application is shutting down. One or more key business functionalities are not working, and the whole system doesn't fulfill the business functionalities. Structured Logging (GCG17003) Structured logging 1 , 2 helps to process log files.","title":"Logging"},{"location":"guidelines/general/17000/#logging","text":"","title":"Logging"},{"location":"guidelines/general/17000/#always-use-a-logging-framework-gcg17001","text":"Always use a well-established logging framework. They contain all necessary features. Additionally, they have been tested in practice and only contains a few bugs. Exception: Small application, interactive console applications and scripts whose output does not need to be tracked, do not require a logging framework.","title":"Always use a logging framework (GCG17001) "},{"location":"guidelines/general/17000/#define-the-usage-of-log-levels-gcg17002","text":"Suggestion: Log level Description Importance Trace The most fine-grained information only used in rare cases where you need the full visibility of what is happening in your application. Can be used to annotate each step in a complex algorithm. Can be ignored during normal operations. A log level describing events showing step by step. Debug Less granular compared to Trace , but it is more than you will need in everyday use. Should be used for information that may be needed for diagnosis issues and troubleshooting or when running application in the test environment for purpose of making sure everything is running correctly Can be ignored during normal operations. A log level used for events considered to be useful during software debugging. Info The standard log level indicating that something happened, the application entered a certain state, etc. This log level should be purely informative and not looking into them on a regular basis shouldn't result in missing any important information. Can be ignored during normal operations. An event happened, the event is purely informative. Warn The log level that indicates that something unexpected happened in the application, a problem, or a situation that might disturb one of the processes. That doesn't mean that the application failed. Should be used in situations that are unexpected, but the code can continue the work. Unexpected behavior happened inside the application, but it is continuing its work, and the key business features are operating as expected. Error The log level that should be used when the application hits an issue preventing one or more functionalities from properly functioning. One or more functionalities are not working, preventing some functionalities from working correctly. Fatal, Critical The log level that tells that the application encountered an event or entered a state in which one of the crucial business functionality is no longer working. May be used when the application is not able to connect to a crucial data store. Often the application is shutting down. One or more key business functionalities are not working, and the whole system doesn't fulfill the business functionalities.","title":"Define the usage of log levels (GCG17002) "},{"location":"guidelines/general/17000/#structured-logging-gcg17003","text":"Structured logging 1 , 2 helps to process log files.","title":"Structured Logging (GCG17003) "},{"location":"guidelines/general/18000/","text":"Exceptions and Process Termination Don't use exceptions instead of if...else statements (GCG18001) Exceptions shouldn't be used to make decisions, but to handle errors depending on their reason and impact. This rule combines among others the rules GCG18002 and GCG18003 . Don't throw exceptions and catch them at the same time (GCG18002) // not okay! class Foo { public void AnyMethod() { try { throw new Exceptions(); } catch { // do something } } } // also not okay class Foo { public void AnyMethod() { try { MethodThrowingException(); } catch { // do something } } private void MethodThrowingException() { throw new Exception(); } } // maybe okay class Foo { public void AnyMethod() { try { MethodThrowingException(); } catch { // do something } } public void MethodThrowingException() { throw new Exception(); } } // okay! class Foo { public void AnyMethod() { try { new Bar().MethodThrowingException(); } catch { // do something } } } class Bar { public void MethodThrowingException() { throw new Exception(); } } Instead of catching null pointer exceptions, introduce null validations (GCG18003) Null pointer exceptions arise when an object has an unexpected state. Instead of catching this kind of exceptions, you should validate the objects state. Throw exceptions rather than returning some kind of status value (GCG18004) A code base that uses return values to report success or failure tends to have nested if-statements sprinkled all over the code. Quite often, a caller forgets to check the return value anyway. Structured exception has been introduced to allow you to throw exceptions and catch or replace them at a higher layer. In most systems it is quire common to throw exceptions whenever an unexpected situations occurs. Throw the most specific exception that is appropriate (GCG18005) If it's possible to throw exceptions of a specific type, then you should that the most specific one, which don't need a message, to understand what happen. Provide a rich and meaningful exception message text (GCG18006) The message should explain the cause of the exception, and clearly describe what needs to be done to avoid the exception. Don't swallow errors by catching generic exceptions (GCG18007) Avoid swallowing errors by catching non-specific exceptions, such as Exception , SystemException , and so on, in application code. Only in top-level code, such as a last chance exception handler, you should catch a non-specific exception for logging purposes and a graceful shutdown of the application. Right usage and documentation of exit codes (GCG18008) The application should always send a proper exit code, when the application was shutting down. So other applications can handle the termination of the process and users can understand why and how an application was stopped. Exit code 0 means that the application was successfully stopped without any error. All other codes representing an unexpected situation. All exit code must be documented! Logging in case of unexpected shutdown (GCG18009) If the application stops unexpected, the reason should be logged in the highest possible log level.","title":"Exceptions and Process Termination"},{"location":"guidelines/general/18000/#exceptions-and-process-termination","text":"","title":"Exceptions and Process Termination"},{"location":"guidelines/general/18000/#dont-use-exceptions-instead-of-ifelse-statements-gcg18001","text":"Exceptions shouldn't be used to make decisions, but to handle errors depending on their reason and impact. This rule combines among others the rules GCG18002 and GCG18003 .","title":"Don't use exceptions instead of if...else statements (GCG18001) "},{"location":"guidelines/general/18000/#dont-throw-exceptions-and-catch-them-at-the-same-time-gcg18002","text":"// not okay! class Foo { public void AnyMethod() { try { throw new Exceptions(); } catch { // do something } } } // also not okay class Foo { public void AnyMethod() { try { MethodThrowingException(); } catch { // do something } } private void MethodThrowingException() { throw new Exception(); } } // maybe okay class Foo { public void AnyMethod() { try { MethodThrowingException(); } catch { // do something } } public void MethodThrowingException() { throw new Exception(); } } // okay! class Foo { public void AnyMethod() { try { new Bar().MethodThrowingException(); } catch { // do something } } } class Bar { public void MethodThrowingException() { throw new Exception(); } }","title":"Don't throw exceptions and catch them at the same time (GCG18002) "},{"location":"guidelines/general/18000/#instead-of-catching-null-pointer-exceptions-introduce-null-validations-gcg18003","text":"Null pointer exceptions arise when an object has an unexpected state. Instead of catching this kind of exceptions, you should validate the objects state.","title":"Instead of catching null pointer exceptions, introduce null validations (GCG18003) "},{"location":"guidelines/general/18000/#throw-exceptions-rather-than-returning-some-kind-of-status-value-gcg18004","text":"A code base that uses return values to report success or failure tends to have nested if-statements sprinkled all over the code. Quite often, a caller forgets to check the return value anyway. Structured exception has been introduced to allow you to throw exceptions and catch or replace them at a higher layer. In most systems it is quire common to throw exceptions whenever an unexpected situations occurs.","title":"Throw exceptions rather than returning some kind of status value (GCG18004) "},{"location":"guidelines/general/18000/#throw-the-most-specific-exception-that-is-appropriate-gcg18005","text":"If it's possible to throw exceptions of a specific type, then you should that the most specific one, which don't need a message, to understand what happen.","title":"Throw the most specific exception that is appropriate (GCG18005) "},{"location":"guidelines/general/18000/#provide-a-rich-and-meaningful-exception-message-text-gcg18006","text":"The message should explain the cause of the exception, and clearly describe what needs to be done to avoid the exception.","title":"Provide a rich and meaningful exception message text (GCG18006) "},{"location":"guidelines/general/18000/#dont-swallow-errors-by-catching-generic-exceptions-gcg18007","text":"Avoid swallowing errors by catching non-specific exceptions, such as Exception , SystemException , and so on, in application code. Only in top-level code, such as a last chance exception handler, you should catch a non-specific exception for logging purposes and a graceful shutdown of the application.","title":"Don't swallow errors by catching generic exceptions (GCG18007) "},{"location":"guidelines/general/18000/#right-usage-and-documentation-of-exit-codes-gcg18008","text":"The application should always send a proper exit code, when the application was shutting down. So other applications can handle the termination of the process and users can understand why and how an application was stopped. Exit code 0 means that the application was successfully stopped without any error. All other codes representing an unexpected situation. All exit code must be documented!","title":"Right usage and documentation of exit codes (GCG18008) "},{"location":"guidelines/general/18000/#logging-in-case-of-unexpected-shutdown-gcg18009","text":"If the application stops unexpected, the reason should be logged in the highest possible log level.","title":"Logging in case of unexpected shutdown (GCG18009) "},{"location":"de/./","text":"Einleitung Was ist das? Dieses Dokument soll versuchen Richtlinien und Standards \u00fcber mehrere Programmiersprachen hinweg zu definieren. Nat\u00fcrlich muss man sich auch daran halten, was man selber predigt, weshalb aus meiner t\u00e4glichen Arbeitsweise entstanden sind und diese auch wiederspiegeln. Nicht alle Punkte sind rational zu begr\u00fcnden, einige sind einfach Entscheidungen, die ich f\u00fcr mich getroffen habe, da es mehrere richtige Weisen gibt. Am Ende spielt das allerdings alles keine Rolle, solange man sich konsistent an seine eigenen Regeln h\u00e4lt. Warum solltest Du dieses Dokument nutzen? Auch wenn manche der Meinung sind, dass Coding Guidelines unn\u00f6tiger Overhead sind oder die Kreativit\u00e4t einschr\u00e4nken, hat sich dieser Ansatz bereits \u00fcber mehrere Jahre hin bew\u00e4hrt. Das liegt daran, dass nicht jedem/jeder Entwickler: bewusst ist, dass Code in der Regel 10-mal h\u00e4ufiger gelesen als ge\u00e4ndert wird. bewusst ist, dass manche Konstrukte Probleme verursachen, selbst wenn sie in anderen Programmiersprachen gut funktionieren der Einfluss von bestimmten L\u00f6sungen in Bezug auf z. B. Sicherheit oder Performance, oder das Ignorieren solcher, bekannt ist. versteht, dass andere Entwickler eventuell nicht genug Erfahrung oder Know-How haben um elegante aber m\u00f6glicherweise abstrakte L\u00f6sungen zu verstehen. Grundlagen Selbst wenn dieses Dokument viele Punkte abdeckt, wird es nie alle m\u00f6glichen Szenarien behandeln, alleine um es nicht \u00fcberm\u00e4\u00dfig aufzubl\u00e4hen. Und entgegen der Meinung mancher (Junior) Developers, hei\u00dft es nicht, nur weil etwas nicht ausdr\u00fccklich als schlecht aufgef\u00fchrt wird, dass die Nutzung davon okay ist. Es gibt eine handvoll Regeln, die auf alle Situationen, unabh\u00e4ngig von ihrem Kontext, angewendet werden k\u00f6nnen. Dazu z\u00e4hlen folgende: Principle of least astonishment (a.k.a. POLA) : Entwickler L\u00f6sungen die jeder Versteht und erwartet. Keep it simple, stupid (a.k.a. KISS) : Die einfachste L\u00f6sung ist mehr als ausreichend. You aren't gonna need it (a.k.a. YAGIN) : Erstelle L\u00f6sungen nur f\u00fcr Probleme und Anforderungen die aktuell bestehen, nicht f\u00fcr welche, von denen Du denkst, dass sie in Zukunft gefordert werden. Kannst Du wirklich in Zukunft schauen? Don't repeat yourself (a.k.a. DRY) : Vermeide doppelten Code innerhalb einer Komponente, eines VCS Repositories oder einem bounded context , aber beachte die Regel Rule of Three . Die vier Prinzipien von Objektorientierte Programmierung : Encapsulation (Datenkapselung), Abstraction (Abstraktion), Inheritance (Vererbung) und Polymorphism (Polymorphie) Automatisch generierter Code muss in der Regel nicht den Coding Guidelines entsprechen. Wenn es dennoch m\u00f6glich ist, den Code weitestgehend den Guidelines anzupassen, dann sollte man das machen. Code, der einmalig generiert wird, sollte immer angepasst werden. Unabh\u00e4ngig davon, wie elegant etwas gel\u00f6st wurde, wenn es zu komplex f\u00fcr normale Entwickler ist, es zu ungew\u00f6hnlichen Verhalten f\u00fchrt oder es versucht zuk\u00fcnftig Probleme zu l\u00f6sen, dann ist es vermutlich die falsche L\u00f6sung und sollte neu implementiert werden. Die schlechteste Reaktion eines Entwicklers, wenn man ihn oder sie darauf aufmerksam macht, ist \u201eBut it works!\u201c. Wie fange ich an? Bitte alle Entwickler dieses Dokument einmal aufmerksam und komplett zu lesen. Damit erhalten sie ein erstes Gesp\u00fcr f\u00fcr die hier enthaltenen Regeln. Stelle sicher, dass alle mit den Regeln einverstanden sind. Erstelle eine Projekt Checklist mit den f\u00fcr euch wichtigsten Punkten, die bei jeder der Peer Review genutzt wird. \u00dcberlegt, ob ihr das Originaldokument forken wollt, um eure eigene Version zu erstellen. Nutzt Tools, z. B. IDEs, Compiler Plugins oder Buildtools, um die Guidelines einhalten zu k\u00f6nnen. Die meisten IDEs haben eine intelligente Code Inspection Engine, die, mit etwas Konfiguration, viele der Punkte abdecken kann. Inspiration Dieses Dokument ist stark von den C# Coding Guidelines beeinflusst. Bereits in den letzten Jahren habe ich regelm\u00e4\u00dfig Codesytles oder Coding Guidelines entwickelt und in meine Projekte, sowohl privat als auch beruflich, eingef\u00fchrt. Nun m\u00f6chte ich dieses Wissen nutzen, um etwas allgemein g\u00fcltiges zu schreiben und der Masse zur Verf\u00fcgung zu stellen. Handelt es sich hierbei um einen offiziellen Standard? Nein! Es wird nicht erwartet, dass sich jedes Projekt an diesem Dokument orientiert. Es soll eine Hilfestellung f\u00fcr jeden sein, der sich nicht selbst damit besch\u00e4ftigen m\u00f6chte, aber dennoch innerhalb eines Teams, aber auch \u00fcber mehrere Teams hinweg, eine homogene Developerexperience haben m\u00f6chte. Um bei Entscheidungen zu helfen, welche Regeln wie wichtig sein k\u00f6nnen, habe ich den Guidelines ein Empfehlungslevel beigef\u00fcgt: Guidelines, die Du in allen Situationen anwenden solltest. Dringend empfohlene Guidelines. M\u00f6glicherweise nicht in allen Situationen anwendbar.","title":"Einleitung"},{"location":"de/./#einleitung","text":"","title":"Einleitung"},{"location":"de/./#was-ist-das","text":"Dieses Dokument soll versuchen Richtlinien und Standards \u00fcber mehrere Programmiersprachen hinweg zu definieren. Nat\u00fcrlich muss man sich auch daran halten, was man selber predigt, weshalb aus meiner t\u00e4glichen Arbeitsweise entstanden sind und diese auch wiederspiegeln. Nicht alle Punkte sind rational zu begr\u00fcnden, einige sind einfach Entscheidungen, die ich f\u00fcr mich getroffen habe, da es mehrere richtige Weisen gibt. Am Ende spielt das allerdings alles keine Rolle, solange man sich konsistent an seine eigenen Regeln h\u00e4lt.","title":"Was ist das?"},{"location":"de/./#warum-solltest-du-dieses-dokument-nutzen","text":"Auch wenn manche der Meinung sind, dass Coding Guidelines unn\u00f6tiger Overhead sind oder die Kreativit\u00e4t einschr\u00e4nken, hat sich dieser Ansatz bereits \u00fcber mehrere Jahre hin bew\u00e4hrt. Das liegt daran, dass nicht jedem/jeder Entwickler: bewusst ist, dass Code in der Regel 10-mal h\u00e4ufiger gelesen als ge\u00e4ndert wird. bewusst ist, dass manche Konstrukte Probleme verursachen, selbst wenn sie in anderen Programmiersprachen gut funktionieren der Einfluss von bestimmten L\u00f6sungen in Bezug auf z. B. Sicherheit oder Performance, oder das Ignorieren solcher, bekannt ist. versteht, dass andere Entwickler eventuell nicht genug Erfahrung oder Know-How haben um elegante aber m\u00f6glicherweise abstrakte L\u00f6sungen zu verstehen.","title":"Warum solltest Du dieses Dokument nutzen?"},{"location":"de/./#grundlagen","text":"Selbst wenn dieses Dokument viele Punkte abdeckt, wird es nie alle m\u00f6glichen Szenarien behandeln, alleine um es nicht \u00fcberm\u00e4\u00dfig aufzubl\u00e4hen. Und entgegen der Meinung mancher (Junior) Developers, hei\u00dft es nicht, nur weil etwas nicht ausdr\u00fccklich als schlecht aufgef\u00fchrt wird, dass die Nutzung davon okay ist. Es gibt eine handvoll Regeln, die auf alle Situationen, unabh\u00e4ngig von ihrem Kontext, angewendet werden k\u00f6nnen. Dazu z\u00e4hlen folgende: Principle of least astonishment (a.k.a. POLA) : Entwickler L\u00f6sungen die jeder Versteht und erwartet. Keep it simple, stupid (a.k.a. KISS) : Die einfachste L\u00f6sung ist mehr als ausreichend. You aren't gonna need it (a.k.a. YAGIN) : Erstelle L\u00f6sungen nur f\u00fcr Probleme und Anforderungen die aktuell bestehen, nicht f\u00fcr welche, von denen Du denkst, dass sie in Zukunft gefordert werden. Kannst Du wirklich in Zukunft schauen? Don't repeat yourself (a.k.a. DRY) : Vermeide doppelten Code innerhalb einer Komponente, eines VCS Repositories oder einem bounded context , aber beachte die Regel Rule of Three . Die vier Prinzipien von Objektorientierte Programmierung : Encapsulation (Datenkapselung), Abstraction (Abstraktion), Inheritance (Vererbung) und Polymorphism (Polymorphie) Automatisch generierter Code muss in der Regel nicht den Coding Guidelines entsprechen. Wenn es dennoch m\u00f6glich ist, den Code weitestgehend den Guidelines anzupassen, dann sollte man das machen. Code, der einmalig generiert wird, sollte immer angepasst werden. Unabh\u00e4ngig davon, wie elegant etwas gel\u00f6st wurde, wenn es zu komplex f\u00fcr normale Entwickler ist, es zu ungew\u00f6hnlichen Verhalten f\u00fchrt oder es versucht zuk\u00fcnftig Probleme zu l\u00f6sen, dann ist es vermutlich die falsche L\u00f6sung und sollte neu implementiert werden. Die schlechteste Reaktion eines Entwicklers, wenn man ihn oder sie darauf aufmerksam macht, ist \u201eBut it works!\u201c.","title":"Grundlagen"},{"location":"de/./#wie-fange-ich-an","text":"Bitte alle Entwickler dieses Dokument einmal aufmerksam und komplett zu lesen. Damit erhalten sie ein erstes Gesp\u00fcr f\u00fcr die hier enthaltenen Regeln. Stelle sicher, dass alle mit den Regeln einverstanden sind. Erstelle eine Projekt Checklist mit den f\u00fcr euch wichtigsten Punkten, die bei jeder der Peer Review genutzt wird. \u00dcberlegt, ob ihr das Originaldokument forken wollt, um eure eigene Version zu erstellen. Nutzt Tools, z. B. IDEs, Compiler Plugins oder Buildtools, um die Guidelines einhalten zu k\u00f6nnen. Die meisten IDEs haben eine intelligente Code Inspection Engine, die, mit etwas Konfiguration, viele der Punkte abdecken kann.","title":"Wie fange ich an?"},{"location":"de/./#inspiration","text":"Dieses Dokument ist stark von den C# Coding Guidelines beeinflusst. Bereits in den letzten Jahren habe ich regelm\u00e4\u00dfig Codesytles oder Coding Guidelines entwickelt und in meine Projekte, sowohl privat als auch beruflich, eingef\u00fchrt. Nun m\u00f6chte ich dieses Wissen nutzen, um etwas allgemein g\u00fcltiges zu schreiben und der Masse zur Verf\u00fcgung zu stellen.","title":"Inspiration"},{"location":"de/./#handelt-es-sich-hierbei-um-einen-offiziellen-standard","text":"Nein! Es wird nicht erwartet, dass sich jedes Projekt an diesem Dokument orientiert. Es soll eine Hilfestellung f\u00fcr jeden sein, der sich nicht selbst damit besch\u00e4ftigen m\u00f6chte, aber dennoch innerhalb eines Teams, aber auch \u00fcber mehrere Teams hinweg, eine homogene Developerexperience haben m\u00f6chte. Um bei Entscheidungen zu helfen, welche Regeln wie wichtig sein k\u00f6nnen, habe ich den Guidelines ein Empfehlungslevel beigef\u00fcgt: Guidelines, die Du in allen Situationen anwenden solltest. Dringend empfohlene Guidelines. M\u00f6glicherweise nicht in allen Situationen anwendbar.","title":"Handelt es sich hierbei um einen offiziellen Standard?"},{"location":"de/guidelines/general/11000/","text":"Version Control System (VCS) Immer ein VCS nutzen (GCG11001) Es sollte f\u00fcr jedes Projekt, auch f\u00fcr sehr kleine Skripte, eine VCS genutzt werden. Bei Projekten, die von mehr als einer Person genutzt werden, sollte das Projekt auf einem Remoteserver hinterlegt sein. Die Verwendung eines VCS erlaubt es einen, auf eine sehr einfache und sichere Art und Weise, alle \u00c4nderungen nachvollziehen zu k\u00f6nnen und ungewollte \u00c4nderungen wieder r\u00fcckg\u00e4ngig zu machen. Definieren eines Workflow / einer Branching-Strategie (GCG11002) Damit jeder wei\u00df, wie mit dem verwendeten VCS zu arbeiten ist, sollte im Vorfeld ein Workflow bzw. eine Branching-Strategie definiert werden, die zu dem jeweiligen Projekt passt. Eine Branching-Strategie umfasst die Fragen Wie werden Branches benannt? Wann und wie wird ein neuer Branch erstellt? Wann und wie wird ein Branch gemerged? Wie lange leben Branches? Wie werden \u00fcber das Branching die Versionen abgebildet? Wie bei (fast) jedem Thema in der Softwareentwicklung sollte man nicht das Rad neu erfinden, sondern sich erstmal bestehende L\u00f6sungen anschauen. F\u00fcr das VCS git haben bereits viele schlaue K\u00f6pfe sich Gedanken gemacht und u. A. die Workflows Gitflow , GitLab Flow und GitHub flow entwickelt. Diese k\u00f6nnen entweder direkt \u00fcbernommen werden, oder f\u00fcr die eigene Situation angepasst und kombiniert werden. Peer Review (GCG11003) Bevor \u00c4nderungen produktiv genutzt werden, sollte mindestens eine zweite Person diese \u00fcberpr\u00fcfen. Damit kann der Code sowohl technisch als auch fachlich gepr\u00fcft werden, um die Qualit\u00e4t der \u00c4nderung sicherzustellen. Der perfekte Moment um \u00c4nderungen zu hinterfragen, Alternativen vorzuschlagen und m\u00f6gliche Fehler fr\u00fchzeitig zu erkennen.","title":"Version Control"},{"location":"de/guidelines/general/11000/#version-control-system-vcs","text":"","title":"Version Control System (VCS)"},{"location":"de/guidelines/general/11000/#immer-ein-vcs-nutzen-gcg11001","text":"Es sollte f\u00fcr jedes Projekt, auch f\u00fcr sehr kleine Skripte, eine VCS genutzt werden. Bei Projekten, die von mehr als einer Person genutzt werden, sollte das Projekt auf einem Remoteserver hinterlegt sein. Die Verwendung eines VCS erlaubt es einen, auf eine sehr einfache und sichere Art und Weise, alle \u00c4nderungen nachvollziehen zu k\u00f6nnen und ungewollte \u00c4nderungen wieder r\u00fcckg\u00e4ngig zu machen.","title":"Immer ein VCS nutzen (GCG11001) "},{"location":"de/guidelines/general/11000/#definieren-eines-workflow-einer-branching-strategie-gcg11002","text":"Damit jeder wei\u00df, wie mit dem verwendeten VCS zu arbeiten ist, sollte im Vorfeld ein Workflow bzw. eine Branching-Strategie definiert werden, die zu dem jeweiligen Projekt passt. Eine Branching-Strategie umfasst die Fragen Wie werden Branches benannt? Wann und wie wird ein neuer Branch erstellt? Wann und wie wird ein Branch gemerged? Wie lange leben Branches? Wie werden \u00fcber das Branching die Versionen abgebildet? Wie bei (fast) jedem Thema in der Softwareentwicklung sollte man nicht das Rad neu erfinden, sondern sich erstmal bestehende L\u00f6sungen anschauen. F\u00fcr das VCS git haben bereits viele schlaue K\u00f6pfe sich Gedanken gemacht und u. A. die Workflows Gitflow , GitLab Flow und GitHub flow entwickelt. Diese k\u00f6nnen entweder direkt \u00fcbernommen werden, oder f\u00fcr die eigene Situation angepasst und kombiniert werden.","title":"Definieren eines Workflow / einer Branching-Strategie (GCG11002) "},{"location":"de/guidelines/general/11000/#peer-review-gcg11003","text":"Bevor \u00c4nderungen produktiv genutzt werden, sollte mindestens eine zweite Person diese \u00fcberpr\u00fcfen. Damit kann der Code sowohl technisch als auch fachlich gepr\u00fcft werden, um die Qualit\u00e4t der \u00c4nderung sicherzustellen. Der perfekte Moment um \u00c4nderungen zu hinterfragen, Alternativen vorzuschlagen und m\u00f6gliche Fehler fr\u00fchzeitig zu erkennen.","title":"Peer Review (GCG11003) "},{"location":"de/guidelines/general/12000/","text":"Update Policy Beheben von Sicherheitsl\u00fccken (GCG12001) Sicherheitsl\u00fccken, sowohl selbst produzierte, als auch welche die durch Abh\u00e4ngigkeiten hereinkommen, sollten schnellstm\u00f6glich behoben werden. Abh\u00e4ngigkeiten regelm\u00e4\u00dfig aktualisieren (GCG12002) Abh\u00e4ngigkeiten sollten vor allem aktuell gehalten werden, um nicht in die Situation zu kommen, dass die verwendete Version nicht mehr supported wird, Sicherheitsl\u00fccken und Bugs zu beheben oder Performanceverbesserungen zu erhalten. H\u00e4lt man seine Abh\u00e4ngigkeiten aktuell und m\u00f6chte ein Feature einer neueren Version verwenden, f\u00e4llt der Aufwand um einiges geringer aus. Sofern m\u00f6glich sollten LTS -Versionen verwendet werden. Version Support Policy f\u00fcr eigene Projekte definieren (GCG12003) Wenn andere Leute (sowohl Kunden als auch Kollegen) von der Software abh\u00e4ngig sind, ergibt es Sinn zu definieren, welche Version wie lange und in welchen Umfang unterst\u00fctzt wird und entsprechend Updates erh\u00e4lt. Ebenfalls ist das Thema Abw\u00e4rtskompatibilit\u00e4t f\u00fcr die betroffenen wichtig. Pflegen eines Changelogs (GCG12004) Um eine schnelle \u00dcbersicht \u00fcber alle funktionalen \u00c4nderungen, z. B. neue Funktionen, \u00c4nderungen einer API oder behobene Fehler, zu erhalten, sollte ein Changelog gepflegt werden. F\u00fcr die \u00c4nderungshistorie von konkreten Anpassungen gibt es die Historie des VCS (siehe Immer ein VCS nutzen (GCG11001) ). Software Versioning (GCG12004) Ein verst\u00e4ndliches Versionsschema hilft Leuten, die von der eigenen Software abh\u00e4ngig sind, einen schnellen Einblick zu erhalten, wie wichtig ein Update ist. \u00dcber die Versionsnummer kann ebenfalls der Zweck einer Version kommuniziert werden (Release, Prerelease, Test etc.).","title":"Update Policy"},{"location":"de/guidelines/general/12000/#update-policy","text":"","title":"Update Policy"},{"location":"de/guidelines/general/12000/#beheben-von-sicherheitslucken-gcg12001","text":"Sicherheitsl\u00fccken, sowohl selbst produzierte, als auch welche die durch Abh\u00e4ngigkeiten hereinkommen, sollten schnellstm\u00f6glich behoben werden.","title":"Beheben von Sicherheitsl\u00fccken (GCG12001) "},{"location":"de/guidelines/general/12000/#abhangigkeiten-regelmaig-aktualisieren-gcg12002","text":"Abh\u00e4ngigkeiten sollten vor allem aktuell gehalten werden, um nicht in die Situation zu kommen, dass die verwendete Version nicht mehr supported wird, Sicherheitsl\u00fccken und Bugs zu beheben oder Performanceverbesserungen zu erhalten. H\u00e4lt man seine Abh\u00e4ngigkeiten aktuell und m\u00f6chte ein Feature einer neueren Version verwenden, f\u00e4llt der Aufwand um einiges geringer aus. Sofern m\u00f6glich sollten LTS -Versionen verwendet werden.","title":"Abh\u00e4ngigkeiten regelm\u00e4\u00dfig aktualisieren (GCG12002) "},{"location":"de/guidelines/general/12000/#version-support-policy-fur-eigene-projekte-definieren-gcg12003","text":"Wenn andere Leute (sowohl Kunden als auch Kollegen) von der Software abh\u00e4ngig sind, ergibt es Sinn zu definieren, welche Version wie lange und in welchen Umfang unterst\u00fctzt wird und entsprechend Updates erh\u00e4lt. Ebenfalls ist das Thema Abw\u00e4rtskompatibilit\u00e4t f\u00fcr die betroffenen wichtig.","title":"Version Support Policy f\u00fcr eigene Projekte definieren (GCG12003) "},{"location":"de/guidelines/general/12000/#pflegen-eines-changelogs-gcg12004","text":"Um eine schnelle \u00dcbersicht \u00fcber alle funktionalen \u00c4nderungen, z. B. neue Funktionen, \u00c4nderungen einer API oder behobene Fehler, zu erhalten, sollte ein Changelog gepflegt werden. F\u00fcr die \u00c4nderungshistorie von konkreten Anpassungen gibt es die Historie des VCS (siehe Immer ein VCS nutzen (GCG11001) ).","title":"Pflegen eines Changelogs (GCG12004) "},{"location":"de/guidelines/general/12000/#software-versioning-gcg12004","text":"Ein verst\u00e4ndliches Versionsschema hilft Leuten, die von der eigenen Software abh\u00e4ngig sind, einen schnellen Einblick zu erhalten, wie wichtig ein Update ist. \u00dcber die Versionsnummer kann ebenfalls der Zweck einer Version kommuniziert werden (Release, Prerelease, Test etc.).","title":"Software Versioning (GCG12004) "},{"location":"de/guidelines/general/13000/","text":"Tools und Automatismen Know the basics (GCG13001) Wenn Tools \u00fcber eine Oberfl\u00e4che genutzt werden, dann sollten die dahinterstehenden Prozesse und Mechanismen in den Grundz\u00fcgen bekannt sein. Jeder sollte f\u00e4hig sein, die Tools, die t\u00e4glich genutzt werden, auch ohne oder mit einer anderen Oberfl\u00e4che, sicher zu verwenden. Genauso sollte m\u00f6gliche Probleme und Limitierungen erkannt und verstanden werden k\u00f6nnen. Nutz den (f\u00fcr Dich) passenden Editor (GCG13002) Du solltet den Editor, unabh\u00e4ngig davon, ob es eine vollwertige IDE oder ein Texteditor f\u00fcr die Konsole ist, nutzen, mit dem du am besten arbeiten kannst. Ein solches Tool sollte die Produktivit\u00e4t steigern und zu dem Workload passen. Es kann sein, dass ein Umfeld (Programmiersprache, Arbeitgeber usw.) bestimmte Tools voraussetzt. Diese sollten dann so eingerichtet werden, dass sie die eigenen Anspr\u00fcche erf\u00fcllen und nicht die von Kollegen \u2013 man selbst arbeitet \u00fcberwiegen damit, nicht der Kollege oder die Kollegin. Dazu z\u00e4hlen Shortcuts, Highlighting, Appearance and Behavior, Automatismen etc. Verwendung von CI/CD-Systemen (GCG13003) CI/CD -Systeme k\u00f6nnen alle Schritte (Bauen, Testen, Packen, Verteilen etc.) nach der eigentlichen Entwicklung automatisieren. Diese Tools beschleunigen diese Prozesse und verhindern Fehler. Im besten Fall wird die CI/CD-Pipeline automatisch mit dem Ver\u00f6ffentlichen einer \u00c4nderung ausgel\u00f6st. Ebenfalls k\u00f6nnen Tools zur \u00dcberpr\u00fcfung der Codequalit\u00e4t teil der CI/CD-Pipeline sein. Test- und Produktivversionen d\u00fcrfen nicht lokal gebaut werden (GCG13004) Um sicherzustellen, dass jeder Build reproduzierbar ist, d\u00fcrfen Test- und Produktivversionen nicht lokal gebaut werden, sondern, am besten automatisiert, nur auf einem Buildserver. Dies beschleunigt den Prozess und sorgt f\u00fcr eine erh\u00f6hte Integrit\u00e4t und Konsistenz der Build-Artefakte. Verwendung von Tools zur steigerung der Codequalit\u00e4t (GCG13005) Es gibt diverse M\u00f6glichkeiten, um die Codequalit\u00e4t pr\u00fcfen zu lassen. Die zwei, die am einfachsten zu realisieren sind, sind automatisierte Tests (besonders Unittests) und die Verwendung von Tools zur statischen Codeanalyse. Um Verbesserungen nachweisen zu k\u00f6nnen, sollten entsprechende Metriken gesammelt werden. Das Definieren eines Codestyles oder von Codingguidelienes kann genauso ein Werkzeug darstellen.","title":"Tools und Automatisierung"},{"location":"de/guidelines/general/13000/#tools-und-automatismen","text":"","title":"Tools und Automatismen"},{"location":"de/guidelines/general/13000/#know-the-basics-gcg13001","text":"Wenn Tools \u00fcber eine Oberfl\u00e4che genutzt werden, dann sollten die dahinterstehenden Prozesse und Mechanismen in den Grundz\u00fcgen bekannt sein. Jeder sollte f\u00e4hig sein, die Tools, die t\u00e4glich genutzt werden, auch ohne oder mit einer anderen Oberfl\u00e4che, sicher zu verwenden. Genauso sollte m\u00f6gliche Probleme und Limitierungen erkannt und verstanden werden k\u00f6nnen.","title":"Know the basics (GCG13001) "},{"location":"de/guidelines/general/13000/#nutz-den-fur-dich-passenden-editor-gcg13002","text":"Du solltet den Editor, unabh\u00e4ngig davon, ob es eine vollwertige IDE oder ein Texteditor f\u00fcr die Konsole ist, nutzen, mit dem du am besten arbeiten kannst. Ein solches Tool sollte die Produktivit\u00e4t steigern und zu dem Workload passen. Es kann sein, dass ein Umfeld (Programmiersprache, Arbeitgeber usw.) bestimmte Tools voraussetzt. Diese sollten dann so eingerichtet werden, dass sie die eigenen Anspr\u00fcche erf\u00fcllen und nicht die von Kollegen \u2013 man selbst arbeitet \u00fcberwiegen damit, nicht der Kollege oder die Kollegin. Dazu z\u00e4hlen Shortcuts, Highlighting, Appearance and Behavior, Automatismen etc.","title":"Nutz den (f\u00fcr Dich) passenden Editor (GCG13002) "},{"location":"de/guidelines/general/13000/#verwendung-von-cicd-systemen-gcg13003","text":"CI/CD -Systeme k\u00f6nnen alle Schritte (Bauen, Testen, Packen, Verteilen etc.) nach der eigentlichen Entwicklung automatisieren. Diese Tools beschleunigen diese Prozesse und verhindern Fehler. Im besten Fall wird die CI/CD-Pipeline automatisch mit dem Ver\u00f6ffentlichen einer \u00c4nderung ausgel\u00f6st. Ebenfalls k\u00f6nnen Tools zur \u00dcberpr\u00fcfung der Codequalit\u00e4t teil der CI/CD-Pipeline sein.","title":"Verwendung von CI/CD-Systemen (GCG13003) "},{"location":"de/guidelines/general/13000/#test-und-produktivversionen-durfen-nicht-lokal-gebaut-werden-gcg13004","text":"Um sicherzustellen, dass jeder Build reproduzierbar ist, d\u00fcrfen Test- und Produktivversionen nicht lokal gebaut werden, sondern, am besten automatisiert, nur auf einem Buildserver. Dies beschleunigt den Prozess und sorgt f\u00fcr eine erh\u00f6hte Integrit\u00e4t und Konsistenz der Build-Artefakte.","title":"Test- und Produktivversionen d\u00fcrfen nicht lokal gebaut werden (GCG13004) "},{"location":"de/guidelines/general/13000/#verwendung-von-tools-zur-steigerung-der-codequalitat-gcg13005","text":"Es gibt diverse M\u00f6glichkeiten, um die Codequalit\u00e4t pr\u00fcfen zu lassen. Die zwei, die am einfachsten zu realisieren sind, sind automatisierte Tests (besonders Unittests) und die Verwendung von Tools zur statischen Codeanalyse. Um Verbesserungen nachweisen zu k\u00f6nnen, sollten entsprechende Metriken gesammelt werden. Das Definieren eines Codestyles oder von Codingguidelienes kann genauso ein Werkzeug darstellen.","title":"Verwendung von Tools zur steigerung der Codequalit\u00e4t (GCG13005) "},{"location":"de/guidelines/general/14000/","text":"Namenskonvention Verwende US English (GCG14001) Alle Identifier (Typen, Member, Parameter, Variablen etc.) sollte mit W\u00f6rtern aus dem amerikanischen Englisch gebildet werden. Die Namen sollten leicht lesbar und grammatikalisch richtig sein. Beispiel: HorizontalAlginment ist besser als AlignmentHorizontal Lesbarkeit ist wichtiger als K\u00fcrze. Beispiel: CanScrollHorizontally ist besser als ScrollableX Bei den Namen sollte auf Schl\u00fcsselw\u00f6rter aus den verbreiteten Programmiersprachen verzichtet werden. Verwende die richtige Schreibweise f\u00fcr Sprachelemente (GCG14002) Abh\u00e4ngig von der jeweiligen Sprache sollte die richtige Schreibweise f\u00fcr Sprachelemente wie z. B. Klassen, Methoden und Variablen gew\u00e4hlt werden. Die am meisten verbreiteten sind Camel Case, Pascal Case, Snake Case und Kebab Case . Verwende keine Zahlen in Variablen, Parametern und anderen Member (GCG14003) Solche Namen resultieren meisten aus Faulheit. Entweder weil man sich nicht genug Gedanken \u00fcber einen passenden Namen gemacht hat, oder man mehrere Elemente, statt einer Liste implementiert hat. Verwende keine Pr\u00e4fixe (GCG14004) Typen, Member, Parameter, Variablen etc. sollten nicht mit einem Pr\u00e4fix versehen werden, um ihren Typ oder Scope zu definieren. Bekannt sind z. B. die Pr\u00e4fixe g_ f\u00fcr global , s_ f\u00fcr static oder string , i_ f\u00fcr \u00eenteger und _ f\u00fcr private Member. Nicht in allen Sprachen ist es m\u00f6glich, diese Regel umzusetzen. In einigen Sprachen werden Backingfields mit dem Pr\u00e4fix _ versehen. In andere Sprachen ist dieses Pr\u00e4fix f\u00fcr private oder spezielle Member n\u00f6tig. Verwende keine Abk\u00fcrzungen (GCG14005) Abk\u00fcrzungen wie btn f\u00fcr Button und cmd f\u00fcr Command tragen nicht zur Lesbarkeit und Verst\u00e4ndlichkeit bei und sollten daher nicht genutzt. Ebenfalls sollten Namen vermieden werden, die nur aus einem Buchstaben bestehen, z. B. i f\u00fcr index und q f\u00fcr query . Ausnahme: es sollten nur Abk\u00fcrzungen genutzt werden, die allgemein oder in der jeweiligen Dom\u00e4ne gel\u00e4ufig sind. Benenne Member, Parameter und Variablen entsprechend ihrer Bedeutung, nicht ihres Typen (GCG14006) Der Name sollte die Funktion wiederspiegeln und nicht den dahinter stehenden Typen. Namen f\u00fcr Listen und Maps sollten den Plural verwenden. Nutze bei der Benennung von Typen Substantive, Substantiv-Phrasen oder Adjektiv-Phrasen (GCG14007) Benennung Beispiel Substantiv IComponent Substantiv-Phrase ICustomAttributeProvider Adjektiv-Phrase IPersistable Nutze bei der Benennung von Methoden Verben oder Verb-Objekt-Paare (GCG14008) Benennung Beispiel Verb Show Verb-Objekt-Paar ShowDialog Die Namen sollten ein Hinweis darauf sein, was die Methode macht. W\u00e4hle bei der Benennung von generischen Parametern aussagekr\u00e4ftige Namen (GCG14009) Pr\u00e4fixe generische Parameter mit dem Buchstaben T f\u00fcr Type . Verwende einen Namen, der die Bedeutung des \u00fcbergebenen Typen erkl\u00e4rt. W\u00e4hle Namen entsprechend anderer Member innerhalb der jeweiligen Sprache oder des jeweiligen Frameworks (GCG14010) Um einen Entwickler, der bereits mit einer Sprache oder einem Framework vertraut ist, den Einstieg in ein Projekt m\u00f6glichst leicht zu machen, sollte Namen verwendet werden, die in der jeweiligen Sprache bzw. dem jeweiligen Framework verwendet werden. Vermeide Namen, die verwechselt werden k\u00f6nnen (GCG14011) Nur weil ein Ausdruck technisch korrekt ist, muss er nicht verst\u00e4ndlich sein. bool b001 = (lo == l0) ? (I1 == 11) : (lOl != 101); Wiederhole nicht den Namen eines Typen innerhalb seiner Member (GCG14013) class Employee { // Wrong! static GetEmployee() {...} DeleteEmployee() {...} // Right static Get() {...} Delete() {...} // Also correct. AddNewJob() {...} RegisterForMeeting() {...} } Vermeide Klassennamen die W\u00f6rter wie Utility oder Helper beinhalten (GCG14013) Klassen, die W\u00f6rter wie Utility oder Helper in dem Namen haben, sind meist statisch und entstehen durch Missachten von den Regeln der objektorientierten Programmierung. Vermeide Methodennamen das Wort And beinhalten (GCG14014) Methoden, die das Wort And beinhalten, machen meist mehr als eine Sache und versto\u00dfen damit gegen das Single Responsibility Principle . Pr\u00e4fixen von booleschen Variablen und Member (GCG14015) Um die Aussagekraft von booleschen Variablen oder Member zu erh\u00f6hen, sollten diese mit den Worten is , has , can , allows oder supports versehen werden.","title":"Namenskonvention"},{"location":"de/guidelines/general/14000/#namenskonvention","text":"","title":"Namenskonvention"},{"location":"de/guidelines/general/14000/#verwende-us-english-gcg14001","text":"Alle Identifier (Typen, Member, Parameter, Variablen etc.) sollte mit W\u00f6rtern aus dem amerikanischen Englisch gebildet werden. Die Namen sollten leicht lesbar und grammatikalisch richtig sein. Beispiel: HorizontalAlginment ist besser als AlignmentHorizontal Lesbarkeit ist wichtiger als K\u00fcrze. Beispiel: CanScrollHorizontally ist besser als ScrollableX Bei den Namen sollte auf Schl\u00fcsselw\u00f6rter aus den verbreiteten Programmiersprachen verzichtet werden.","title":"Verwende US English (GCG14001) "},{"location":"de/guidelines/general/14000/#verwende-die-richtige-schreibweise-fur-sprachelemente-gcg14002","text":"Abh\u00e4ngig von der jeweiligen Sprache sollte die richtige Schreibweise f\u00fcr Sprachelemente wie z. B. Klassen, Methoden und Variablen gew\u00e4hlt werden. Die am meisten verbreiteten sind Camel Case, Pascal Case, Snake Case und Kebab Case .","title":"Verwende die richtige Schreibweise f\u00fcr Sprachelemente (GCG14002) "},{"location":"de/guidelines/general/14000/#verwende-keine-zahlen-in-variablen-parametern-und-anderen-member-gcg14003","text":"Solche Namen resultieren meisten aus Faulheit. Entweder weil man sich nicht genug Gedanken \u00fcber einen passenden Namen gemacht hat, oder man mehrere Elemente, statt einer Liste implementiert hat.","title":"Verwende keine Zahlen in Variablen, Parametern und anderen Member (GCG14003) "},{"location":"de/guidelines/general/14000/#verwende-keine-prafixe-gcg14004","text":"Typen, Member, Parameter, Variablen etc. sollten nicht mit einem Pr\u00e4fix versehen werden, um ihren Typ oder Scope zu definieren. Bekannt sind z. B. die Pr\u00e4fixe g_ f\u00fcr global , s_ f\u00fcr static oder string , i_ f\u00fcr \u00eenteger und _ f\u00fcr private Member. Nicht in allen Sprachen ist es m\u00f6glich, diese Regel umzusetzen. In einigen Sprachen werden Backingfields mit dem Pr\u00e4fix _ versehen. In andere Sprachen ist dieses Pr\u00e4fix f\u00fcr private oder spezielle Member n\u00f6tig.","title":"Verwende keine Pr\u00e4fixe (GCG14004) "},{"location":"de/guidelines/general/14000/#verwende-keine-abkurzungen-gcg14005","text":"Abk\u00fcrzungen wie btn f\u00fcr Button und cmd f\u00fcr Command tragen nicht zur Lesbarkeit und Verst\u00e4ndlichkeit bei und sollten daher nicht genutzt. Ebenfalls sollten Namen vermieden werden, die nur aus einem Buchstaben bestehen, z. B. i f\u00fcr index und q f\u00fcr query . Ausnahme: es sollten nur Abk\u00fcrzungen genutzt werden, die allgemein oder in der jeweiligen Dom\u00e4ne gel\u00e4ufig sind.","title":"Verwende keine Abk\u00fcrzungen (GCG14005) "},{"location":"de/guidelines/general/14000/#benenne-member-parameter-und-variablen-entsprechend-ihrer-bedeutung-nicht-ihres-typen-gcg14006","text":"Der Name sollte die Funktion wiederspiegeln und nicht den dahinter stehenden Typen. Namen f\u00fcr Listen und Maps sollten den Plural verwenden.","title":"Benenne Member, Parameter und Variablen entsprechend ihrer Bedeutung, nicht ihres Typen (GCG14006) "},{"location":"de/guidelines/general/14000/#nutze-bei-der-benennung-von-typen-substantive-substantiv-phrasen-oder-adjektiv-phrasen-gcg14007","text":"Benennung Beispiel Substantiv IComponent Substantiv-Phrase ICustomAttributeProvider Adjektiv-Phrase IPersistable","title":"Nutze bei der Benennung von Typen Substantive, Substantiv-Phrasen oder Adjektiv-Phrasen (GCG14007) "},{"location":"de/guidelines/general/14000/#nutze-bei-der-benennung-von-methoden-verben-oder-verb-objekt-paare-gcg14008","text":"Benennung Beispiel Verb Show Verb-Objekt-Paar ShowDialog Die Namen sollten ein Hinweis darauf sein, was die Methode macht.","title":"Nutze bei der Benennung von Methoden Verben oder Verb-Objekt-Paare (GCG14008) "},{"location":"de/guidelines/general/14000/#wahle-bei-der-benennung-von-generischen-parametern-aussagekraftige-namen-gcg14009","text":"Pr\u00e4fixe generische Parameter mit dem Buchstaben T f\u00fcr Type . Verwende einen Namen, der die Bedeutung des \u00fcbergebenen Typen erkl\u00e4rt.","title":"W\u00e4hle bei der Benennung von generischen Parametern aussagekr\u00e4ftige Namen (GCG14009) "},{"location":"de/guidelines/general/14000/#wahle-namen-entsprechend-anderer-member-innerhalb-der-jeweiligen-sprache-oder-des-jeweiligen-frameworks-gcg14010","text":"Um einen Entwickler, der bereits mit einer Sprache oder einem Framework vertraut ist, den Einstieg in ein Projekt m\u00f6glichst leicht zu machen, sollte Namen verwendet werden, die in der jeweiligen Sprache bzw. dem jeweiligen Framework verwendet werden.","title":"W\u00e4hle Namen entsprechend anderer Member innerhalb der jeweiligen Sprache oder des jeweiligen Frameworks (GCG14010) "},{"location":"de/guidelines/general/14000/#vermeide-namen-die-verwechselt-werden-konnen-gcg14011","text":"Nur weil ein Ausdruck technisch korrekt ist, muss er nicht verst\u00e4ndlich sein. bool b001 = (lo == l0) ? (I1 == 11) : (lOl != 101);","title":"Vermeide Namen, die verwechselt werden k\u00f6nnen (GCG14011) "},{"location":"de/guidelines/general/14000/#wiederhole-nicht-den-namen-eines-typen-innerhalb-seiner-member-gcg14013","text":"class Employee { // Wrong! static GetEmployee() {...} DeleteEmployee() {...} // Right static Get() {...} Delete() {...} // Also correct. AddNewJob() {...} RegisterForMeeting() {...} }","title":"Wiederhole nicht den Namen eines Typen innerhalb seiner Member (GCG14013) "},{"location":"de/guidelines/general/14000/#vermeide-klassennamen-die-worter-wie-utility-oder-helper-beinhalten-gcg14013","text":"Klassen, die W\u00f6rter wie Utility oder Helper in dem Namen haben, sind meist statisch und entstehen durch Missachten von den Regeln der objektorientierten Programmierung.","title":"Vermeide Klassennamen die W\u00f6rter wie Utility oder Helper beinhalten (GCG14013) "},{"location":"de/guidelines/general/14000/#vermeide-methodennamen-das-wort-and-beinhalten-gcg14014","text":"Methoden, die das Wort And beinhalten, machen meist mehr als eine Sache und versto\u00dfen damit gegen das Single Responsibility Principle .","title":"Vermeide Methodennamen das Wort And beinhalten (GCG14014) "},{"location":"de/guidelines/general/14000/#prafixen-von-booleschen-variablen-und-member-gcg14015","text":"Um die Aussagekraft von booleschen Variablen oder Member zu erh\u00f6hen, sollten diese mit den Worten is , has , can , allows oder supports versehen werden.","title":"Pr\u00e4fixen von booleschen Variablen und Member (GCG14015) "},{"location":"de/guidelines/general/15000/","text":"Maintainability Eine Methode sollte nicht mehr als 7 Statements haben (GCG15001) Eine Methode mit mehr als sieben Statements macht zu viel oder verst\u00f6\u00dft gegen das Single Responsibility Principle . Au\u00dferdem wird es mit jedem Statement aufw\u00e4ndiger zu verstehen, was der Code machen soll. Eine Methode mit mehr Statements sollte entsprechend in mehrere kleine Methoden, die einen selbsterkl\u00e4renden Namen haben, runtergebrochen werden. Der High-Level Algorithmus muss allerdings weiterhin verst\u00e4ndlich sein. Eine Ausnahme hierbei k\u00f6nnen Tests, Builder oder Methoden, die den Anwendungsfluss steuern sein. Es sollte dennoch gepr\u00fcft werden, ob die Anzahl der Statements pro Methode durch Pattern oder verschachtelte Pr\u00fcfungen reduziert werden k\u00f6nnen, wodurch die Verst\u00e4ndlichkeit und Wartbarkeit gesteigert werden kann. So geschlossen wie m\u00f6glich, so offen wie n\u00f6tig (GCG15002) Alle Typen und Member sollten standardm\u00e4\u00dfig nur von denen gesehen und genutzt werden k\u00f6nnen, die auf diese Typen und Member direkt zugreifen m\u00fcssen. Entsprechend sollten Member standardm\u00e4\u00dfig private und Typen internal sein. Au\u00dferdem sollten standardm\u00e4\u00dfig weder Member noch Typen \u00fcberschrieben oder beerbt werden k\u00f6nnen. Nur f\u00fcr den Fall, dass von Au\u00dfen auf einen Typen oder dessen Member zugegriffen werden muss, sollte die Sichtbarkeit langsam erh\u00f6ht werden. Vermeidung von Ausdr\u00fccken mit doppelter Negierung (GCG15003) In manchen F\u00e4llen ist es sinnvoll, oder gegeben, dass eine Variable bzw. ein Typen-Member den Negativfall abdeckt, allerdings sollte es vermieden werden, diese in einer negierten Bedingung zu verwenden. bool hasOrders = !customer.HasNoOrders; Doppelte Verneinungen sind schwerer zu verstehen und werden oft \u00fcberlesen. Ein Typ, eine Datei (GCG15004) Eine Source-Datei sollte genau einen Typen enthalten, bzw. einen Zweck dienen. Die Datei sollte auch nach diesem Typen benannt sein. Ausnahme: Nested-Types sollten Teil der Datei des \u00fcbergeordneten Typen sein. Ausnahme: Typen, die sich nur durch die Anzahl an generischen Typ-Parametern unterscheiden, sollten Teil der gleichen Datei sein. Don't use magic numbers (GCG15005) Vermeide die Verwendung von Literal Values, sowohl Zahlen als auch Strings. Stattdessen sollten Konstanten verwendet werden. Ausgenommen sind Strings f\u00fcr das Logging, sowie Werte, die durch ihren Context eindeutig sind und zuk\u00fcnftig nicht ge\u00e4ndert werden. mean = (a + b) / 2; // okay WaitMilliseconds(waitTimeInSeconds * 1000); // clear enough Anmerkung: Enum-Typen eigenen sich oft f\u00fcr Konstanten genutzt werden. Explizit, statt Implizit (GCG15006) Die Deklarierung sollte immer so explizit wie m\u00f6glich sein. Variablen sollten so sp\u00e4t wie m\u00f6glich deklariert und initialisiert werden (GCG15007) Variablen sollten zu dem Zeitpunkt deklariert und initialisiert werden, an dem sie gebraucht werden. Deklariere und Weise immer nur eine Variable pro Zeile zu (GCG15008) Vermeide Ausdr\u00fccke wie var result = otherVariable = GetSomeValue(); Keine explizite Vergleiche auf True und False (GCG15009) if (condition == false) // wrong; bad style if (condition != true) // also wrong if (((condition == true) == true) == true) // where do you stop? if (condition) // OK Ver\u00e4ndere nicht die Loop-Variable innerhalb eines for -Loops (GCG15010) Das Updaten der Loop-Variablen innerhalb des Loops f\u00fcr in aller Regel zu Verwirrung, besonders, wenn sie an mehr als einer Stelle ver\u00e4ndert wird. for (int index = 0; index < 10; index++) { if (someCondition) { index = 11; // Wrong! Use 'break' or 'continue' instead. } } Vermeide verschachtelte Loops (GCG15011) Methoden mit verschachtelten Loops ist schwerer zu verstehen, als eine Methode mit nur einem Loop. Werden verschachtelte Loops ben\u00f6tigt, sollten diese durch andere Mittel ersetzt werden, oder in mehrere Methoden aufgeteilt werden. F\u00fcge immer den default -Block nach dem letzten case in einem switch -Statement hinzu (GCG15012) Wenn der default -Block leer gelassen werden soll, dann f\u00fcge ein aussagekr\u00e4ftiges Kommentar hinzu. Wenn der Block nicht erreicht werden darf, dann wird eine Exception, um zuk\u00fcnftige \u00c4nderungen zu erkennen, die bisher nicht erwartet werden. Beende jedes if - else - if -Statement mit einem else -Statement (GCG15013) Verwende den letzten else -Block f\u00fcr das Standardverhalten. Wenn dieser Block nicht erreicht werden kann oder darf, dann wird eine Exception. Verwende ein einfaches Conditional Assignment Statement, statt einem if - else -Konstrukt (GCG15013) // rather than: bool isPositive; if (value > 0) { isPositive = true; } else { isPositive = false; } // write: bool isPositive = (value > 0); Verwende switch -Statements, statt if - else -Statement (GCG15014) In vielen F\u00e4llen kann ein switch -Statement ein if - else -Statement abl\u00f6sen und es dadurch verst\u00e4ndlicher und wartbarer gestalten. Vermeide Signaturen mit mehr als 3 Parametern (GCG15015) Um Konstruktoren, Methoden, Funktionen etc. klein und fokussiert zu halten, muss die Anzahl der Parameter gering gehalten werden. Es empfiehlt sich, die Anzahl auf drei Parameter zu beschr\u00e4nken. Konstruktoren, zum Erstellen von Typen, die mehrere Parameter erwarten, k\u00f6nnen z. B. durch das Builder-Pattern vereinfacht werden. Generell gilt, desto weniger Parameter, umso einfacher und verst\u00e4ndlicher ist die Methode. Au\u00dferdem resultiert das Testen von Methoden, die viele Parameter erwarten, in vielen Szenarien, die abgedeckt werden m\u00fcssen. Vermeide Signaturen, die einen bool -Parameter haben (GCG15016) Folgendes Beispiel: public Customer CreateCustomer(bool hasPlatinumLevel) {} Auf den ersten Blick wirkt die Signatur verst\u00e4ndlich, aber sobald die Methode verwendet wird, geht die Verst\u00e4ndlichkeit verloren: Customer customer = CreateCustomer(true); Oft macht eine Methode, die einen Boolean erwartet mehr als eine Sache. Eine Alternative ist es, den Boolean mit einer Enumeration zu ersetzen. Kommentiere niemals Code aus (GCG15017) Ver\u00f6ffentliche niemals eine \u00c4nderung, in der Code auskommentiert ist. Niemand wird wissen, weshalb der Code auskommentiert ist. Wurde es tempor\u00e4r zum Testen entfernt? Ist es ein kopiertes Beispiel? Kann der Code gel\u00f6scht werden? Schreib code, der leicht zu debuggen ist (GCG15018) Vermeide es, zu viele Statements innerhalb einer einzigen Zeile zu schreiben. Dadurch k\u00f6nnen Debugger effektiver genutzt werden. \u00dcberladungen sollten sich gegenseitig aufrufen (GCG15019) Diese Regel betrifft nur \u00dcberladungen, die optionale Parameter bereitstellen. public string ToString() { return ToString(Format.Default); } public string ToString(Format format) { return ToString(format, Culture.Default); } public string ToString(Format format, Culture culture) { // return result } Lagere komplexe Ausdr\u00fccke in separaten Methoden aus (GCG15020) Komplexe Ausdr\u00fccke, z. B. Bedingungen, sollten in Methoden mit eindeutigen Namen ausgelagert werden, damit diese verst\u00e4ndlicher werden.","title":"Maintainability"},{"location":"de/guidelines/general/15000/#maintainability","text":"","title":"Maintainability"},{"location":"de/guidelines/general/15000/#eine-methode-sollte-nicht-mehr-als-7-statements-haben-gcg15001","text":"Eine Methode mit mehr als sieben Statements macht zu viel oder verst\u00f6\u00dft gegen das Single Responsibility Principle . Au\u00dferdem wird es mit jedem Statement aufw\u00e4ndiger zu verstehen, was der Code machen soll. Eine Methode mit mehr Statements sollte entsprechend in mehrere kleine Methoden, die einen selbsterkl\u00e4renden Namen haben, runtergebrochen werden. Der High-Level Algorithmus muss allerdings weiterhin verst\u00e4ndlich sein. Eine Ausnahme hierbei k\u00f6nnen Tests, Builder oder Methoden, die den Anwendungsfluss steuern sein. Es sollte dennoch gepr\u00fcft werden, ob die Anzahl der Statements pro Methode durch Pattern oder verschachtelte Pr\u00fcfungen reduziert werden k\u00f6nnen, wodurch die Verst\u00e4ndlichkeit und Wartbarkeit gesteigert werden kann.","title":"Eine Methode sollte nicht mehr als 7 Statements haben (GCG15001) "},{"location":"de/guidelines/general/15000/#so-geschlossen-wie-moglich-so-offen-wie-notig-gcg15002","text":"Alle Typen und Member sollten standardm\u00e4\u00dfig nur von denen gesehen und genutzt werden k\u00f6nnen, die auf diese Typen und Member direkt zugreifen m\u00fcssen. Entsprechend sollten Member standardm\u00e4\u00dfig private und Typen internal sein. Au\u00dferdem sollten standardm\u00e4\u00dfig weder Member noch Typen \u00fcberschrieben oder beerbt werden k\u00f6nnen. Nur f\u00fcr den Fall, dass von Au\u00dfen auf einen Typen oder dessen Member zugegriffen werden muss, sollte die Sichtbarkeit langsam erh\u00f6ht werden.","title":"So geschlossen wie m\u00f6glich, so offen wie n\u00f6tig (GCG15002) "},{"location":"de/guidelines/general/15000/#vermeidung-von-ausdrucken-mit-doppelter-negierung-gcg15003","text":"In manchen F\u00e4llen ist es sinnvoll, oder gegeben, dass eine Variable bzw. ein Typen-Member den Negativfall abdeckt, allerdings sollte es vermieden werden, diese in einer negierten Bedingung zu verwenden. bool hasOrders = !customer.HasNoOrders; Doppelte Verneinungen sind schwerer zu verstehen und werden oft \u00fcberlesen.","title":"Vermeidung von Ausdr\u00fccken mit doppelter Negierung (GCG15003) "},{"location":"de/guidelines/general/15000/#ein-typ-eine-datei-gcg15004","text":"Eine Source-Datei sollte genau einen Typen enthalten, bzw. einen Zweck dienen. Die Datei sollte auch nach diesem Typen benannt sein. Ausnahme: Nested-Types sollten Teil der Datei des \u00fcbergeordneten Typen sein. Ausnahme: Typen, die sich nur durch die Anzahl an generischen Typ-Parametern unterscheiden, sollten Teil der gleichen Datei sein.","title":"Ein Typ, eine Datei (GCG15004) "},{"location":"de/guidelines/general/15000/#dont-use-magic-numbers-gcg15005","text":"Vermeide die Verwendung von Literal Values, sowohl Zahlen als auch Strings. Stattdessen sollten Konstanten verwendet werden. Ausgenommen sind Strings f\u00fcr das Logging, sowie Werte, die durch ihren Context eindeutig sind und zuk\u00fcnftig nicht ge\u00e4ndert werden. mean = (a + b) / 2; // okay WaitMilliseconds(waitTimeInSeconds * 1000); // clear enough Anmerkung: Enum-Typen eigenen sich oft f\u00fcr Konstanten genutzt werden.","title":"Don't use magic numbers (GCG15005) "},{"location":"de/guidelines/general/15000/#explizit-statt-implizit-gcg15006","text":"Die Deklarierung sollte immer so explizit wie m\u00f6glich sein.","title":"Explizit, statt Implizit (GCG15006) "},{"location":"de/guidelines/general/15000/#variablen-sollten-so-spat-wie-moglich-deklariert-und-initialisiert-werden-gcg15007","text":"Variablen sollten zu dem Zeitpunkt deklariert und initialisiert werden, an dem sie gebraucht werden.","title":"Variablen sollten so sp\u00e4t wie m\u00f6glich deklariert und initialisiert werden (GCG15007) "},{"location":"de/guidelines/general/15000/#deklariere-und-weise-immer-nur-eine-variable-pro-zeile-zu-gcg15008","text":"Vermeide Ausdr\u00fccke wie var result = otherVariable = GetSomeValue();","title":"Deklariere und Weise immer nur eine Variable pro Zeile zu (GCG15008) "},{"location":"de/guidelines/general/15000/#keine-explizite-vergleiche-auf-true-und-false-gcg15009","text":"if (condition == false) // wrong; bad style if (condition != true) // also wrong if (((condition == true) == true) == true) // where do you stop? if (condition) // OK","title":"Keine explizite Vergleiche auf True und False (GCG15009) "},{"location":"de/guidelines/general/15000/#verandere-nicht-die-loop-variable-innerhalb-eines-for-loops-gcg15010","text":"Das Updaten der Loop-Variablen innerhalb des Loops f\u00fcr in aller Regel zu Verwirrung, besonders, wenn sie an mehr als einer Stelle ver\u00e4ndert wird. for (int index = 0; index < 10; index++) { if (someCondition) { index = 11; // Wrong! Use 'break' or 'continue' instead. } }","title":"Ver\u00e4ndere nicht die Loop-Variable innerhalb eines for-Loops (GCG15010) "},{"location":"de/guidelines/general/15000/#vermeide-verschachtelte-loops-gcg15011","text":"Methoden mit verschachtelten Loops ist schwerer zu verstehen, als eine Methode mit nur einem Loop. Werden verschachtelte Loops ben\u00f6tigt, sollten diese durch andere Mittel ersetzt werden, oder in mehrere Methoden aufgeteilt werden.","title":"Vermeide verschachtelte Loops (GCG15011) "},{"location":"de/guidelines/general/15000/#fuge-immer-den-default-block-nach-dem-letzten-case-in-einem-switch-statement-hinzu-gcg15012","text":"Wenn der default -Block leer gelassen werden soll, dann f\u00fcge ein aussagekr\u00e4ftiges Kommentar hinzu. Wenn der Block nicht erreicht werden darf, dann wird eine Exception, um zuk\u00fcnftige \u00c4nderungen zu erkennen, die bisher nicht erwartet werden.","title":"F\u00fcge immer den default-Block nach dem letzten case in einem switch-Statement hinzu (GCG15012) "},{"location":"de/guidelines/general/15000/#beende-jedes-if-else-if-statement-mit-einem-else-statement-gcg15013","text":"Verwende den letzten else -Block f\u00fcr das Standardverhalten. Wenn dieser Block nicht erreicht werden kann oder darf, dann wird eine Exception.","title":"Beende jedes if-else-if-Statement mit einem else-Statement (GCG15013) "},{"location":"de/guidelines/general/15000/#verwende-ein-einfaches-conditional-assignment-statement-statt-einem-if-else-konstrukt-gcg15013","text":"// rather than: bool isPositive; if (value > 0) { isPositive = true; } else { isPositive = false; } // write: bool isPositive = (value > 0);","title":"Verwende ein einfaches Conditional Assignment Statement, statt einem if-else-Konstrukt (GCG15013) "},{"location":"de/guidelines/general/15000/#verwende-switch-statements-statt-if-else-statement-gcg15014","text":"In vielen F\u00e4llen kann ein switch -Statement ein if - else -Statement abl\u00f6sen und es dadurch verst\u00e4ndlicher und wartbarer gestalten.","title":"Verwende switch-Statements, statt if-else-Statement (GCG15014) "},{"location":"de/guidelines/general/15000/#vermeide-signaturen-mit-mehr-als-3-parametern-gcg15015","text":"Um Konstruktoren, Methoden, Funktionen etc. klein und fokussiert zu halten, muss die Anzahl der Parameter gering gehalten werden. Es empfiehlt sich, die Anzahl auf drei Parameter zu beschr\u00e4nken. Konstruktoren, zum Erstellen von Typen, die mehrere Parameter erwarten, k\u00f6nnen z. B. durch das Builder-Pattern vereinfacht werden. Generell gilt, desto weniger Parameter, umso einfacher und verst\u00e4ndlicher ist die Methode. Au\u00dferdem resultiert das Testen von Methoden, die viele Parameter erwarten, in vielen Szenarien, die abgedeckt werden m\u00fcssen.","title":"Vermeide Signaturen mit mehr als 3 Parametern (GCG15015) "},{"location":"de/guidelines/general/15000/#vermeide-signaturen-die-einen-bool-parameter-haben-gcg15016","text":"Folgendes Beispiel: public Customer CreateCustomer(bool hasPlatinumLevel) {} Auf den ersten Blick wirkt die Signatur verst\u00e4ndlich, aber sobald die Methode verwendet wird, geht die Verst\u00e4ndlichkeit verloren: Customer customer = CreateCustomer(true); Oft macht eine Methode, die einen Boolean erwartet mehr als eine Sache. Eine Alternative ist es, den Boolean mit einer Enumeration zu ersetzen.","title":"Vermeide Signaturen, die einen bool-Parameter haben (GCG15016) "},{"location":"de/guidelines/general/15000/#kommentiere-niemals-code-aus-gcg15017","text":"Ver\u00f6ffentliche niemals eine \u00c4nderung, in der Code auskommentiert ist. Niemand wird wissen, weshalb der Code auskommentiert ist. Wurde es tempor\u00e4r zum Testen entfernt? Ist es ein kopiertes Beispiel? Kann der Code gel\u00f6scht werden?","title":"Kommentiere niemals Code aus (GCG15017) "},{"location":"de/guidelines/general/15000/#schreib-code-der-leicht-zu-debuggen-ist-gcg15018","text":"Vermeide es, zu viele Statements innerhalb einer einzigen Zeile zu schreiben. Dadurch k\u00f6nnen Debugger effektiver genutzt werden.","title":"Schreib code, der leicht zu debuggen ist (GCG15018) "},{"location":"de/guidelines/general/15000/#uberladungen-sollten-sich-gegenseitig-aufrufen-gcg15019","text":"Diese Regel betrifft nur \u00dcberladungen, die optionale Parameter bereitstellen. public string ToString() { return ToString(Format.Default); } public string ToString(Format format) { return ToString(format, Culture.Default); } public string ToString(Format format, Culture culture) { // return result }","title":"\u00dcberladungen sollten sich gegenseitig aufrufen (GCG15019) "},{"location":"de/guidelines/general/15000/#lagere-komplexe-ausdrucke-in-separaten-methoden-aus-gcg15020","text":"Komplexe Ausdr\u00fccke, z. B. Bedingungen, sollten in Methoden mit eindeutigen Namen ausgelagert werden, damit diese verst\u00e4ndlicher werden.","title":"Lagere komplexe Ausdr\u00fccke in separaten Methoden aus (GCG15020) "},{"location":"de/guidelines/general/16000/","text":"Dokumentation Verwende US Englisch f\u00fcr Kommentare (CGC16001) Verwende US Englisch f\u00fcr Dokumentation (CGC16002) Dokumentiere alle von au\u00dferhalb verf\u00fcgbaren Typen und Members (CGC16003) Alle Typen und Members, die von au\u00dferhalb des Programmes, aber auch au\u00dferhalb Namespaces, Paketen oder Typen innerhalb des Programmes erreichbar sind, sollten mit, f\u00fcr die jeweilige Sprache standardisierte Style, dokumentiert werden. Auf diesen Weg k\u00f6nnen andere Entwickler den Verwendungszweck und die Verwendung verstehen, ohne den eigentlichen Code zu kennen. Au\u00dferdem ist es m\u00f6glich, mit entsprechenden Tools, eine professionell aussehende Dokumentation zu erstellen. Schreibe Dokumentation f\u00fcr andere (CGC16004) Dokumentation sollte f\u00fcr Nutzer geschrieben werden, die den dahinterstehenden Code nicht kennen. Sowohl der Verwendungszweck als auch die Verwendung sollte klar erkl\u00e4rt werden, um die bestm\u00f6gliche Verwendung sicherzustellen. Vermeide Inline-Kommentare (CGC16005) Wenn Inline-Kommentare n\u00f6tig sind, sollte es in betracht gezogen werden, ob es besser w\u00e4re, den betroffenen Code in eine eigene Methode mit einem aussagekr\u00e4ftigen Namen auszulagern. Verwende keine Kommentare, um zuk\u00fcnftige Aufgaben festzuhalten (CGC16006) Es ist gut, wenn Arbeit, die aktuell nicht erledigt werden konnte, festzuhalten, allerdings sollte dies in einem Projektmanagementsystem erfolgen. Die Verwendung von TODO -Kommentare ist zwar auch eine M\u00f6glichkeit, allerdings wird in der Praxis nicht oder nur selten nach solchen Kommentaren gesucht und gel\u00f6st. Eine weitere M\u00f6glichkeit ist eine Kombination aus beiden. Ein Ticket in dem jeweiligen Projektmanagementsystem anlegen und ein dazugeh\u00f6riges TODO -Kommentar anlegen und in diesem das Ticket referenzieren. Schreib Kommentare um komplexe Algorithmen oder Entscheidungen zu erkl\u00e4ren (CGC16007) Kommentare sollten sich auf das Was? und Warum? konzentrieren, statt auf dem Wie? . Die Statements sollten nicht Zeile f\u00fcr Zeile erkl\u00e4rt werden, sondern es sollte das Ziel erkl\u00e4rt werden, und weshalb genau diese L\u00f6sung verwendet wurde, wenn sie einer offensichtlicheren vorgezogen wurde, z. B. welche Probleme dadurch vermieden werden.","title":"Dokumentation"},{"location":"de/guidelines/general/16000/#dokumentation","text":"","title":"Dokumentation"},{"location":"de/guidelines/general/16000/#verwende-us-englisch-fur-kommentare-cgc16001","text":"","title":"Verwende US Englisch f\u00fcr Kommentare (CGC16001) "},{"location":"de/guidelines/general/16000/#verwende-us-englisch-fur-dokumentation-cgc16002","text":"","title":"Verwende US Englisch f\u00fcr Dokumentation (CGC16002) "},{"location":"de/guidelines/general/16000/#dokumentiere-alle-von-auerhalb-verfugbaren-typen-und-members-cgc16003","text":"Alle Typen und Members, die von au\u00dferhalb des Programmes, aber auch au\u00dferhalb Namespaces, Paketen oder Typen innerhalb des Programmes erreichbar sind, sollten mit, f\u00fcr die jeweilige Sprache standardisierte Style, dokumentiert werden. Auf diesen Weg k\u00f6nnen andere Entwickler den Verwendungszweck und die Verwendung verstehen, ohne den eigentlichen Code zu kennen. Au\u00dferdem ist es m\u00f6glich, mit entsprechenden Tools, eine professionell aussehende Dokumentation zu erstellen.","title":"Dokumentiere alle von au\u00dferhalb verf\u00fcgbaren Typen und Members (CGC16003) "},{"location":"de/guidelines/general/16000/#schreibe-dokumentation-fur-andere-cgc16004","text":"Dokumentation sollte f\u00fcr Nutzer geschrieben werden, die den dahinterstehenden Code nicht kennen. Sowohl der Verwendungszweck als auch die Verwendung sollte klar erkl\u00e4rt werden, um die bestm\u00f6gliche Verwendung sicherzustellen.","title":"Schreibe Dokumentation f\u00fcr andere (CGC16004) "},{"location":"de/guidelines/general/16000/#vermeide-inline-kommentare-cgc16005","text":"Wenn Inline-Kommentare n\u00f6tig sind, sollte es in betracht gezogen werden, ob es besser w\u00e4re, den betroffenen Code in eine eigene Methode mit einem aussagekr\u00e4ftigen Namen auszulagern.","title":"Vermeide Inline-Kommentare (CGC16005) "},{"location":"de/guidelines/general/16000/#verwende-keine-kommentare-um-zukunftige-aufgaben-festzuhalten-cgc16006","text":"Es ist gut, wenn Arbeit, die aktuell nicht erledigt werden konnte, festzuhalten, allerdings sollte dies in einem Projektmanagementsystem erfolgen. Die Verwendung von TODO -Kommentare ist zwar auch eine M\u00f6glichkeit, allerdings wird in der Praxis nicht oder nur selten nach solchen Kommentaren gesucht und gel\u00f6st. Eine weitere M\u00f6glichkeit ist eine Kombination aus beiden. Ein Ticket in dem jeweiligen Projektmanagementsystem anlegen und ein dazugeh\u00f6riges TODO -Kommentar anlegen und in diesem das Ticket referenzieren.","title":"Verwende keine Kommentare, um zuk\u00fcnftige Aufgaben festzuhalten (CGC16006) "},{"location":"de/guidelines/general/16000/#schreib-kommentare-um-komplexe-algorithmen-oder-entscheidungen-zu-erklaren-cgc16007","text":"Kommentare sollten sich auf das Was? und Warum? konzentrieren, statt auf dem Wie? . Die Statements sollten nicht Zeile f\u00fcr Zeile erkl\u00e4rt werden, sondern es sollte das Ziel erkl\u00e4rt werden, und weshalb genau diese L\u00f6sung verwendet wurde, wenn sie einer offensichtlicheren vorgezogen wurde, z. B. welche Probleme dadurch vermieden werden.","title":"Schreib Kommentare um komplexe Algorithmen oder Entscheidungen zu erkl\u00e4ren (CGC16007) "},{"location":"de/guidelines/general/17000/","text":"Logging Verwende immer ein Logging-Framework (GCG17001) Verwende immer ein etabliertes Logging-Framework, da diese bereits alle n\u00f6tigen Funktionen beinhalten. Au\u00dferdem sind sie bereits in der praxis erprobt und beinhalten wenig Bugs. Ausnahme: Kleine Anwendungen, interaktive Konsolen Anwendungen und Skripte, deren Ausgabe nicht nachvollzogen werden muss, ben\u00f6tigen kein Logging-Framework. Definiere die Verwendung der Log-Levels (GCG17002) Vorschlag: Log-Level Beschreibung Aussage Trace Sehr genaues Loggen, das zur Diagnose genutzt werden kann oder zum nachvollziehen einzelner Algorithmen. Kann im normalen Betrieb ignoriert werden. Wird ggf. in Debug-Sessions ben\u00f6tigt. Debug Weniger ausf\u00fchrlich als Trace , aber immer noch mehr, als im normalen Betrieb ben\u00f6tigt wird. Kann zur Ausgabe von Informationen genutzt werden, die f\u00fcr die Diagnose notwendig sind. Kann im normalen Betrieb ignoriert werden. Wird z. B. f\u00fcr das Debuggen ben\u00f6tigt. Info Standard Log-Level um auszusagen, dass etwas passiert ist. Sollten rein Informativ sein und sollte alle wichtigen Informationen beinhalten. Kann im normalen Betrieb ignoriert werden. Etwas ist geschehen, dient nur zur Information. Warn Sagt aus, dass etwas unerwartetes geschehen ist, das den weiteren Prozess st\u00f6ren kann. Das bedeutet aber nicht, dass die Anwendung oder der Prozess abgest\u00fcrzt ist. Sollte f\u00fcr unerwartete F\u00e4lle verwendet werden, die aber ein Fortlaufen des Programmes nicht verhindern. Unerwartetes Verhalten innerhalb der Anwendung, die Anwendung arbeitet aber wie erwartet weiter. Error Sollte verwendet werden, wenn ein Situation entsteht, die den Prozess vom richtigen weiterarbeiten Abh\u00e4lt. Eine oder mehrere Funktionalit\u00e4ten werden abgehalten richtig zu arbeiten. Fatal, Critical Dieses Log-Level sagt aus, dass die Anwendung einen Zustand erreicht hat, in der die Kernfunktionen nicht mehr gew\u00e4hrleistet sind, z. B. da eine notwendige Datenbank nicht erreichbar ist. Oftmals wird an dieser Stelle die Anwendung zur Sicherheit beendet. Eine oder mehrere Kern-Funktionen arbeiten nicht weiter und das gesamte System kann nicht weiter arbeiten. System wird zwangsweise beendet. Structured Logging (GCG17003) Structured Logging 1 , 2 hilft bei der Verarbeitung von Logfiles.","title":"Logging"},{"location":"de/guidelines/general/17000/#logging","text":"","title":"Logging"},{"location":"de/guidelines/general/17000/#verwende-immer-ein-logging-framework-gcg17001","text":"Verwende immer ein etabliertes Logging-Framework, da diese bereits alle n\u00f6tigen Funktionen beinhalten. Au\u00dferdem sind sie bereits in der praxis erprobt und beinhalten wenig Bugs. Ausnahme: Kleine Anwendungen, interaktive Konsolen Anwendungen und Skripte, deren Ausgabe nicht nachvollzogen werden muss, ben\u00f6tigen kein Logging-Framework.","title":"Verwende immer ein Logging-Framework (GCG17001) "},{"location":"de/guidelines/general/17000/#definiere-die-verwendung-der-log-levels-gcg17002","text":"Vorschlag: Log-Level Beschreibung Aussage Trace Sehr genaues Loggen, das zur Diagnose genutzt werden kann oder zum nachvollziehen einzelner Algorithmen. Kann im normalen Betrieb ignoriert werden. Wird ggf. in Debug-Sessions ben\u00f6tigt. Debug Weniger ausf\u00fchrlich als Trace , aber immer noch mehr, als im normalen Betrieb ben\u00f6tigt wird. Kann zur Ausgabe von Informationen genutzt werden, die f\u00fcr die Diagnose notwendig sind. Kann im normalen Betrieb ignoriert werden. Wird z. B. f\u00fcr das Debuggen ben\u00f6tigt. Info Standard Log-Level um auszusagen, dass etwas passiert ist. Sollten rein Informativ sein und sollte alle wichtigen Informationen beinhalten. Kann im normalen Betrieb ignoriert werden. Etwas ist geschehen, dient nur zur Information. Warn Sagt aus, dass etwas unerwartetes geschehen ist, das den weiteren Prozess st\u00f6ren kann. Das bedeutet aber nicht, dass die Anwendung oder der Prozess abgest\u00fcrzt ist. Sollte f\u00fcr unerwartete F\u00e4lle verwendet werden, die aber ein Fortlaufen des Programmes nicht verhindern. Unerwartetes Verhalten innerhalb der Anwendung, die Anwendung arbeitet aber wie erwartet weiter. Error Sollte verwendet werden, wenn ein Situation entsteht, die den Prozess vom richtigen weiterarbeiten Abh\u00e4lt. Eine oder mehrere Funktionalit\u00e4ten werden abgehalten richtig zu arbeiten. Fatal, Critical Dieses Log-Level sagt aus, dass die Anwendung einen Zustand erreicht hat, in der die Kernfunktionen nicht mehr gew\u00e4hrleistet sind, z. B. da eine notwendige Datenbank nicht erreichbar ist. Oftmals wird an dieser Stelle die Anwendung zur Sicherheit beendet. Eine oder mehrere Kern-Funktionen arbeiten nicht weiter und das gesamte System kann nicht weiter arbeiten. System wird zwangsweise beendet.","title":"Definiere die Verwendung der Log-Levels (GCG17002) "},{"location":"de/guidelines/general/17000/#structured-logging-gcg17003","text":"Structured Logging 1 , 2 hilft bei der Verarbeitung von Logfiles.","title":"Structured Logging (GCG17003) "},{"location":"de/guidelines/general/18000/","text":"Exceptions und Prozessbeendigung Verwende keine Exceptions statt if...else -Statements (GCG18001) Exceptions sollten nicht verwendet werden, um Entscheidungen zu treffen, sondern um Fehler entsprechend ihrer Ursache und m\u00f6glichen Auswirkungen zu behandeln. Diese Regel kombiniert u. A. die Regeln GCG18002 und CGC18003 . Werf keine Exceptions die direkt wieder gefangen werden (GCG18002) // not okay! class Foo { public void AnyMethod() { try { throw new Exceptions(); } catch { // do something } } } // also not okay class Foo { public void AnyMethod() { try { MethodThrowingException(); } catch { // do something } } private void MethodThrowingException() { throw new Exception(); } } // maybe okay class Foo { public void AnyMethod() { try { MethodThrowingException(); } catch { // do something } } public void MethodThrowingException() { throw new Exception(); } } // okay! class Foo { public void AnyMethod() { try { new Bar().MethodThrowingException(); } catch { // do something } } } class Bar { public void MethodThrowingException() { throw new Exception(); } } Statt NullPointer-Exceptions zu fangen, pr\u00fcfe sie vorzeitig ab (GCG18003) NullPointer-Exceptions entstehen, wenn ein Objekt einen nicht erwarteten Zustand hat. Statt im Prozess solche Exceptions abzufangen, sollten sie fr\u00fch erkannt und entsprechend behandelt werden. Werf eine Exception, statt eine Art von Status-Code zur\u00fcckzugeben (GCG18004) Eine Codebasis die R\u00fcckgabewerte verwendet um einen Status (erfolgreich oder fehlgeschlagen) zu kommunizieren, tendiert dazu, viele verschachtelte if -Statements \u00fcberall verteilt zu haben. Oft wird auch vergessen, den R\u00fcckgabewert ordentlich zu pr\u00fcfen. Geworfene Exceptions k\u00f6nnen abgefangen oder durch eine genauere Exception ersetzt werden, um sie an auf einer h\u00f6heren Ebene zu behandeln. In den meisten Systemen ist es normal, dass Exceptions immer dann geworfen werden, wenn eine unerwartete Situation auftaucht. Werf eine m\u00f6glichst genaue Exception (GCG18005) Wenn es m\u00f6glich ist, eine Exception von einem spezifischen Typ zu werfen, dann sollte ein Typ gew\u00e4hlt werden, der bereits ohne zus\u00e4tzliche Message genau aussagt, was passiert ist. Nutze aussagekr\u00e4ftige Exception-Messages (GCG18006) Die Exceptions-Message sollte den Grund f\u00fcr die Exception erkl\u00e4ren und eindeutig beschreiben was getan werden muss, um die Exception zu vermeiden. Vermeide das Verbergen von Fehlern durch das Abfangen von generischen Exceptions (GCG18007) Vermeide das Abfangen von nicht spezifischen Exceptions, wie z. B. Exception , SystemException etc. Nur auf der h\u00f6chsten Ebene, als letzte Chance eine Exception abzufangen, sollten nicht spezifische Exceptions behandelt werden, um einen graceful Shutdown zu erm\u00f6glichen. Richtige Verwendung und Dokumentation von Exit-Codes (GCG18008) Es sollte immer sichergestellt werden, dass beim Beenden der Applikation ein zutreffender Exit-Code ausgegeben wird. Dadurch ist es anderen Systemen m\u00f6glich auf das Beenden der Anwendung zu reagieren, au\u00dferdem k\u00f6nnen Benutzer nachvollziehen wie und warum eine Anwendung beendet wurde. Es hat sich etabliert, dass der Exit-Code 0 f\u00fcr ein erwartetes und erfolgreiches Beenden steht, hingegen alle abweichenden einen Fehler oder eine unerwartete Situation repr\u00e4sentieren. Alle Exit Codes m\u00fcssen dokumentiert werden! Logging bei gezwungener Beendigung (GCG18009) Wenn die Anwendung unerwartet beendet wird, sollte der Grund mit dem h\u00f6chsten Log-Level dokumentiert werden.","title":"Exceptions und Prozessbeendigung"},{"location":"de/guidelines/general/18000/#exceptions-und-prozessbeendigung","text":"","title":"Exceptions und Prozessbeendigung"},{"location":"de/guidelines/general/18000/#verwende-keine-exceptions-statt-ifelse-statements-gcg18001","text":"Exceptions sollten nicht verwendet werden, um Entscheidungen zu treffen, sondern um Fehler entsprechend ihrer Ursache und m\u00f6glichen Auswirkungen zu behandeln. Diese Regel kombiniert u. A. die Regeln GCG18002 und CGC18003 .","title":"Verwende keine Exceptions statt if...else-Statements (GCG18001) "},{"location":"de/guidelines/general/18000/#werf-keine-exceptions-die-direkt-wieder-gefangen-werden-gcg18002","text":"// not okay! class Foo { public void AnyMethod() { try { throw new Exceptions(); } catch { // do something } } } // also not okay class Foo { public void AnyMethod() { try { MethodThrowingException(); } catch { // do something } } private void MethodThrowingException() { throw new Exception(); } } // maybe okay class Foo { public void AnyMethod() { try { MethodThrowingException(); } catch { // do something } } public void MethodThrowingException() { throw new Exception(); } } // okay! class Foo { public void AnyMethod() { try { new Bar().MethodThrowingException(); } catch { // do something } } } class Bar { public void MethodThrowingException() { throw new Exception(); } }","title":"Werf keine Exceptions die direkt wieder gefangen werden (GCG18002) "},{"location":"de/guidelines/general/18000/#statt-nullpointer-exceptions-zu-fangen-prufe-sie-vorzeitig-ab-gcg18003","text":"NullPointer-Exceptions entstehen, wenn ein Objekt einen nicht erwarteten Zustand hat. Statt im Prozess solche Exceptions abzufangen, sollten sie fr\u00fch erkannt und entsprechend behandelt werden.","title":"Statt NullPointer-Exceptions zu fangen, pr\u00fcfe sie vorzeitig ab  (GCG18003) "},{"location":"de/guidelines/general/18000/#werf-eine-exception-statt-eine-art-von-status-code-zuruckzugeben-gcg18004","text":"Eine Codebasis die R\u00fcckgabewerte verwendet um einen Status (erfolgreich oder fehlgeschlagen) zu kommunizieren, tendiert dazu, viele verschachtelte if -Statements \u00fcberall verteilt zu haben. Oft wird auch vergessen, den R\u00fcckgabewert ordentlich zu pr\u00fcfen. Geworfene Exceptions k\u00f6nnen abgefangen oder durch eine genauere Exception ersetzt werden, um sie an auf einer h\u00f6heren Ebene zu behandeln. In den meisten Systemen ist es normal, dass Exceptions immer dann geworfen werden, wenn eine unerwartete Situation auftaucht.","title":"Werf eine Exception, statt eine Art von Status-Code zur\u00fcckzugeben (GCG18004) "},{"location":"de/guidelines/general/18000/#werf-eine-moglichst-genaue-exception-gcg18005","text":"Wenn es m\u00f6glich ist, eine Exception von einem spezifischen Typ zu werfen, dann sollte ein Typ gew\u00e4hlt werden, der bereits ohne zus\u00e4tzliche Message genau aussagt, was passiert ist.","title":"Werf eine m\u00f6glichst genaue Exception (GCG18005) "},{"location":"de/guidelines/general/18000/#nutze-aussagekraftige-exception-messages-gcg18006","text":"Die Exceptions-Message sollte den Grund f\u00fcr die Exception erkl\u00e4ren und eindeutig beschreiben was getan werden muss, um die Exception zu vermeiden.","title":"Nutze aussagekr\u00e4ftige Exception-Messages (GCG18006) "},{"location":"de/guidelines/general/18000/#vermeide-das-verbergen-von-fehlern-durch-das-abfangen-von-generischen-exceptions-gcg18007","text":"Vermeide das Abfangen von nicht spezifischen Exceptions, wie z. B. Exception , SystemException etc. Nur auf der h\u00f6chsten Ebene, als letzte Chance eine Exception abzufangen, sollten nicht spezifische Exceptions behandelt werden, um einen graceful Shutdown zu erm\u00f6glichen.","title":"Vermeide das Verbergen von Fehlern durch das Abfangen von generischen Exceptions (GCG18007) "},{"location":"de/guidelines/general/18000/#richtige-verwendung-und-dokumentation-von-exit-codes-gcg18008","text":"Es sollte immer sichergestellt werden, dass beim Beenden der Applikation ein zutreffender Exit-Code ausgegeben wird. Dadurch ist es anderen Systemen m\u00f6glich auf das Beenden der Anwendung zu reagieren, au\u00dferdem k\u00f6nnen Benutzer nachvollziehen wie und warum eine Anwendung beendet wurde. Es hat sich etabliert, dass der Exit-Code 0 f\u00fcr ein erwartetes und erfolgreiches Beenden steht, hingegen alle abweichenden einen Fehler oder eine unerwartete Situation repr\u00e4sentieren. Alle Exit Codes m\u00fcssen dokumentiert werden!","title":"Richtige Verwendung und Dokumentation von Exit-Codes (GCG18008) "},{"location":"de/guidelines/general/18000/#logging-bei-gezwungener-beendigung-gcg18009","text":"Wenn die Anwendung unerwartet beendet wird, sollte der Grund mit dem h\u00f6chsten Log-Level dokumentiert werden.","title":"Logging bei gezwungener Beendigung (GCG18009) "}]}