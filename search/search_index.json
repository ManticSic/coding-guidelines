{"config":{"indexing":"full","lang":["en","de"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction What is this? This document attempts to provide guidelines for multiple programming languages. Of course, if you create such a document you should practice what you preach. So rest assured, these guidelines are representative to what I do in my day-to-day work. Notice that not all guidelines have a clear rationale. Some of them are simply choices I have made. In the end, it doesn't matter what choice you made, as long as you make one and apply it consistently. Why would you use this document? Although some might see coding guidelines as undesired overhead or something that limits creativity, this approach has already proven its value for many years. This is because not every developer: is aware that code is generally read 10 times more than it is changed. is aware of the potential pitfalls in one programming language, which are a good way in other. is aware of the impact of using (or neglecting to use) particular solutions on aspects like security, performance, multi-language support, etc. realizes that not every developer is as capable, skilled or experienced to understand elegant, but potentially very abstract solutions. Basics Even if this document covers many scenarios, it will not cover every possible scenario. But Unlike what some (junior) developers believe, just because something is not explicitly listed as bad, it does not mean that using it is okay. There is a set of rules than can be applied to all situations, regardless of their context. The include the following: Principle of least astonishment (a.k.a. POLA) : you should choose solution that everyone can understand, and that keeps them on the right track. Keep it simple, stupid (a.k.a. KISS) : the simplest solution is more than sufficient. You aren't gonna need it (a.k.a. YAGIN) : create a solution for the problem at hand, not for the ones you think may happen later on. Can you predict the future? Don't repeat yourself (a.k.a. DRY) : avoid duplication within a component, a source control repository or a bounded context , without forgetting the Rule of Three heuristic. The four principles of object-oriented programming : encapsulation, abstraction, inheritance and polymorphism. In general, generated code should not need to comply with coding guidelines. However, if it is possible to modify the templates used for generation, try to make them generate code that complies as much as possible. Regardless of the elegance of someone's solution, if it's too complex for the ordinary developer, exposes unusual behavior, or tries to solve many possible future issues, it es very likely the wrong solution and needs redesign. The worst response a developer can give yo to these principles is: \"But it works!\". Wie fange ich an? Ask all developers to carefully read this document at least once. This will give them a sense of the kind of guidelines the document containes. Make sure evereybody agrees with the rules. Create a project checklist with the most important rules and use this checklist for your Peer Review . Consider forking the original source and create your own internal version of the document. Use tools, e. g. IDEs, compiler plugins or build tools, to be able to comply with these guidelines. THe most IDEs have a intelligent code instpection engine, with some configuration, already supporting many aspects of the Coding Guidelines. Inspiration This document is inspired by C# Coding Guidelines . In the last years I often created some kind of code styles and coding guidelines, which I used in both, private and professional projects. Now I would like to use this knowledge to write some general guidelines. Is this a coding standard? Definitely not! This document does not state that projects must comply with these guidelines, neither does it say which guidelines are more important than other. It is intended to be a guide for anyone who does not want to deal with creating own rules but still wants to have a homogeneous developer experience within one team, but also across multiple teams. However, to help with decisions about which rules may be important, I have added a recommendation level to each rule: Guidelines that you should never skip and should be applicable to all situations. Strongly recommended guidelines May not be applicable in all situations","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#what-is-this","text":"This document attempts to provide guidelines for multiple programming languages. Of course, if you create such a document you should practice what you preach. So rest assured, these guidelines are representative to what I do in my day-to-day work. Notice that not all guidelines have a clear rationale. Some of them are simply choices I have made. In the end, it doesn't matter what choice you made, as long as you make one and apply it consistently.","title":"What is this?"},{"location":"#why-would-you-use-this-document","text":"Although some might see coding guidelines as undesired overhead or something that limits creativity, this approach has already proven its value for many years. This is because not every developer: is aware that code is generally read 10 times more than it is changed. is aware of the potential pitfalls in one programming language, which are a good way in other. is aware of the impact of using (or neglecting to use) particular solutions on aspects like security, performance, multi-language support, etc. realizes that not every developer is as capable, skilled or experienced to understand elegant, but potentially very abstract solutions.","title":"Why would you use this document?"},{"location":"#basics","text":"Even if this document covers many scenarios, it will not cover every possible scenario. But Unlike what some (junior) developers believe, just because something is not explicitly listed as bad, it does not mean that using it is okay. There is a set of rules than can be applied to all situations, regardless of their context. The include the following: Principle of least astonishment (a.k.a. POLA) : you should choose solution that everyone can understand, and that keeps them on the right track. Keep it simple, stupid (a.k.a. KISS) : the simplest solution is more than sufficient. You aren't gonna need it (a.k.a. YAGIN) : create a solution for the problem at hand, not for the ones you think may happen later on. Can you predict the future? Don't repeat yourself (a.k.a. DRY) : avoid duplication within a component, a source control repository or a bounded context , without forgetting the Rule of Three heuristic. The four principles of object-oriented programming : encapsulation, abstraction, inheritance and polymorphism. In general, generated code should not need to comply with coding guidelines. However, if it is possible to modify the templates used for generation, try to make them generate code that complies as much as possible. Regardless of the elegance of someone's solution, if it's too complex for the ordinary developer, exposes unusual behavior, or tries to solve many possible future issues, it es very likely the wrong solution and needs redesign. The worst response a developer can give yo to these principles is: \"But it works!\".","title":"Basics"},{"location":"#wie-fange-ich-an","text":"Ask all developers to carefully read this document at least once. This will give them a sense of the kind of guidelines the document containes. Make sure evereybody agrees with the rules. Create a project checklist with the most important rules and use this checklist for your Peer Review . Consider forking the original source and create your own internal version of the document. Use tools, e. g. IDEs, compiler plugins or build tools, to be able to comply with these guidelines. THe most IDEs have a intelligent code instpection engine, with some configuration, already supporting many aspects of the Coding Guidelines.","title":"Wie fange ich an?"},{"location":"#inspiration","text":"This document is inspired by C# Coding Guidelines . In the last years I often created some kind of code styles and coding guidelines, which I used in both, private and professional projects. Now I would like to use this knowledge to write some general guidelines.","title":"Inspiration"},{"location":"#is-this-a-coding-standard","text":"Definitely not! This document does not state that projects must comply with these guidelines, neither does it say which guidelines are more important than other. It is intended to be a guide for anyone who does not want to deal with creating own rules but still wants to have a homogeneous developer experience within one team, but also across multiple teams. However, to help with decisions about which rules may be important, I have added a recommendation level to each rule: Guidelines that you should never skip and should be applicable to all situations. Strongly recommended guidelines May not be applicable in all situations","title":"Is this a coding standard?"},{"location":"guidelines/general/11000/","text":"en Translation coming soon Version Control System (VCS) Immer ein VCS nutzen (GCG11001) Es sollte f\u00fcr jedes Projekt, auch f\u00fcr sehr kleine Skripte, eine VCS genutzt werden. Bei Projekten, die von mehr als einer Person genutzt werden, sollte das Projekt auf einem Remoteserver hinterlegt sein. Die Verwendung eines VCS erlaubt es einen, auf eine sehr einfache und sichere Art und Weise, alle \u00c4nderungen nachvollziehen zu k\u00f6nnen und ungewollte \u00c4nderungen wieder r\u00fcckg\u00e4ngig zu machen. Definieren eines Workflow / einer Branching-Strategie (GCG11002) Damit jeder wei\u00df, wie mit dem verwendeten VCS zu arbeiten ist, sollte im Vorfeld ein Workflow bzw. eine Branching-Strategie definiert werden, die zu dem jeweiligen Projekt passt. Eine Branching-Strategie umfasst die Fragen Wie werden Branches benannt? Wann und wie wird ein neuer Branch erstellt? Wann und wie wird ein Branch gemerged? Wie lange leben Branches? Wie werden \u00fcber das Branching die Versionen abgebildet? Wie bei (fast) jedem Thema in der Softwareentwicklung sollte man nicht das Rad neu erfinden, sondern sich erstmal bestehende L\u00f6sungen anschauen. F\u00fcr das VCS git haben bereits viele schlaue K\u00f6pfe sich Gedanken gemacht und u. A. die Workflows Gitflow , GitLab Flow und GitHub flow entwickelt. Diese k\u00f6nnen entweder direkt \u00fcbernommen werden, oder f\u00fcr die eigene Situation angepasst und kombiniert werden. Peer Review (GCG11003) Bevor \u00c4nderungen produktiv genutzt werden, sollte mindestens eine zweite Person diese \u00fcberpr\u00fcfen. Damit kann der Code sowohl technisch als auch fachlich gepr\u00fcft werden, um die Qualit\u00e4t der \u00c4nderung sicherzustellen. Der perfekte Moment um \u00c4nderungen zu hinterfragen, Alternativen vorzuschlagen und m\u00f6gliche Fehler fr\u00fchzeitig zu erkennen.","title":"Version Control"},{"location":"guidelines/general/11000/#version-control-system-vcs","text":"","title":"Version Control System (VCS)"},{"location":"guidelines/general/11000/#immer-ein-vcs-nutzen-gcg11001","text":"Es sollte f\u00fcr jedes Projekt, auch f\u00fcr sehr kleine Skripte, eine VCS genutzt werden. Bei Projekten, die von mehr als einer Person genutzt werden, sollte das Projekt auf einem Remoteserver hinterlegt sein. Die Verwendung eines VCS erlaubt es einen, auf eine sehr einfache und sichere Art und Weise, alle \u00c4nderungen nachvollziehen zu k\u00f6nnen und ungewollte \u00c4nderungen wieder r\u00fcckg\u00e4ngig zu machen.","title":"Immer ein VCS nutzen (GCG11001) "},{"location":"guidelines/general/11000/#definieren-eines-workflow-einer-branching-strategie-gcg11002","text":"Damit jeder wei\u00df, wie mit dem verwendeten VCS zu arbeiten ist, sollte im Vorfeld ein Workflow bzw. eine Branching-Strategie definiert werden, die zu dem jeweiligen Projekt passt. Eine Branching-Strategie umfasst die Fragen Wie werden Branches benannt? Wann und wie wird ein neuer Branch erstellt? Wann und wie wird ein Branch gemerged? Wie lange leben Branches? Wie werden \u00fcber das Branching die Versionen abgebildet? Wie bei (fast) jedem Thema in der Softwareentwicklung sollte man nicht das Rad neu erfinden, sondern sich erstmal bestehende L\u00f6sungen anschauen. F\u00fcr das VCS git haben bereits viele schlaue K\u00f6pfe sich Gedanken gemacht und u. A. die Workflows Gitflow , GitLab Flow und GitHub flow entwickelt. Diese k\u00f6nnen entweder direkt \u00fcbernommen werden, oder f\u00fcr die eigene Situation angepasst und kombiniert werden.","title":"Definieren eines Workflow / einer Branching-Strategie (GCG11002) "},{"location":"guidelines/general/11000/#peer-review-gcg11003","text":"Bevor \u00c4nderungen produktiv genutzt werden, sollte mindestens eine zweite Person diese \u00fcberpr\u00fcfen. Damit kann der Code sowohl technisch als auch fachlich gepr\u00fcft werden, um die Qualit\u00e4t der \u00c4nderung sicherzustellen. Der perfekte Moment um \u00c4nderungen zu hinterfragen, Alternativen vorzuschlagen und m\u00f6gliche Fehler fr\u00fchzeitig zu erkennen.","title":"Peer Review (GCG11003) "},{"location":"guidelines/general/12000/","text":"en Translation coming soon Update Policy Beheben von Sicherheitsl\u00fccken (GCG12001) Sicherheitsl\u00fccken, sowohl selbst produzierte, als auch welche die durch Abh\u00e4ngigkeiten hereinkommen, sollten schnellstm\u00f6glich behoben werden. Abh\u00e4ngigkeiten regelm\u00e4\u00dfig aktualisieren (GCG12002) Abh\u00e4ngigkeiten sollten vor allem aktuell gehalten werden, um nicht in die Situation zu kommen, dass die verwendete Version nicht mehr supported wird, Sicherheitsl\u00fccken und Bugs zu beheben oder Performanceverbesserungen zu erhalten. H\u00e4lt man seine Abh\u00e4ngigkeiten aktuell und m\u00f6chte ein Feature einer neueren Version verwenden, f\u00e4llt der Aufwand um einiges geringer aus. Sofern m\u00f6glich sollten LTS -Versionen verwendet werden. Version Support Policy f\u00fcr eigene Projekte definieren (GCG12003) Wenn andere Leute (sowohl Kunden als auch Kollegen) von der Software abh\u00e4ngig sind, ergibt es Sinn zu definieren, welche Version wie lange und in welchen Umfang unterst\u00fctzt wird und entsprechend Updates erh\u00e4lt. Ebenfalls ist das Thema Abw\u00e4rtskompatibilit\u00e4t f\u00fcr die betroffenen wichtig. Pflegen eines Changelogs (GCG12004) Um eine schnelle \u00dcbersicht \u00fcber alle funktionalen \u00c4nderungen, z. B. neue Funktionen, \u00c4nderungen einer API oder behobene Fehler, zu erhalten, sollte ein Changelog gepflegt werden. F\u00fcr die \u00c4nderungshistorie von konkreten Anpassungen gibt es die Historie des VCS (siehe Immer ein VCS nutzen (GCG11001) ). Software Versioning (GCG12004) Ein verst\u00e4ndliches Versionsschema hilft Leuten, die von der eigenen Software abh\u00e4ngig sind, einen schnellen Einblick zu erhalten, wie wichtig ein Update ist. \u00dcber die Versionsnummer kann ebenfalls der Zweck einer Version kommuniziert werden (Release, Prerelease, Test etc.).","title":"Update Policy"},{"location":"guidelines/general/12000/#update-policy","text":"","title":"Update Policy"},{"location":"guidelines/general/12000/#beheben-von-sicherheitslucken-gcg12001","text":"Sicherheitsl\u00fccken, sowohl selbst produzierte, als auch welche die durch Abh\u00e4ngigkeiten hereinkommen, sollten schnellstm\u00f6glich behoben werden.","title":"Beheben von Sicherheitsl\u00fccken (GCG12001) "},{"location":"guidelines/general/12000/#abhangigkeiten-regelmaig-aktualisieren-gcg12002","text":"Abh\u00e4ngigkeiten sollten vor allem aktuell gehalten werden, um nicht in die Situation zu kommen, dass die verwendete Version nicht mehr supported wird, Sicherheitsl\u00fccken und Bugs zu beheben oder Performanceverbesserungen zu erhalten. H\u00e4lt man seine Abh\u00e4ngigkeiten aktuell und m\u00f6chte ein Feature einer neueren Version verwenden, f\u00e4llt der Aufwand um einiges geringer aus. Sofern m\u00f6glich sollten LTS -Versionen verwendet werden.","title":"Abh\u00e4ngigkeiten regelm\u00e4\u00dfig aktualisieren (GCG12002) "},{"location":"guidelines/general/12000/#version-support-policy-fur-eigene-projekte-definieren-gcg12003","text":"Wenn andere Leute (sowohl Kunden als auch Kollegen) von der Software abh\u00e4ngig sind, ergibt es Sinn zu definieren, welche Version wie lange und in welchen Umfang unterst\u00fctzt wird und entsprechend Updates erh\u00e4lt. Ebenfalls ist das Thema Abw\u00e4rtskompatibilit\u00e4t f\u00fcr die betroffenen wichtig.","title":"Version Support Policy f\u00fcr eigene Projekte definieren (GCG12003) "},{"location":"guidelines/general/12000/#pflegen-eines-changelogs-gcg12004","text":"Um eine schnelle \u00dcbersicht \u00fcber alle funktionalen \u00c4nderungen, z. B. neue Funktionen, \u00c4nderungen einer API oder behobene Fehler, zu erhalten, sollte ein Changelog gepflegt werden. F\u00fcr die \u00c4nderungshistorie von konkreten Anpassungen gibt es die Historie des VCS (siehe Immer ein VCS nutzen (GCG11001) ).","title":"Pflegen eines Changelogs (GCG12004) "},{"location":"guidelines/general/12000/#software-versioning-gcg12004","text":"Ein verst\u00e4ndliches Versionsschema hilft Leuten, die von der eigenen Software abh\u00e4ngig sind, einen schnellen Einblick zu erhalten, wie wichtig ein Update ist. \u00dcber die Versionsnummer kann ebenfalls der Zweck einer Version kommuniziert werden (Release, Prerelease, Test etc.).","title":"Software Versioning (GCG12004) "},{"location":"guidelines/general/13000/","text":"en Translation coming soon Tools und Automatismen Know the basics (GCG13001) Wenn Tools \u00fcber eine Oberfl\u00e4che genutzt werden, dann sollten die dahinterstehenden Prozesse und Mechanismen in den Grundz\u00fcgen bekannt sein. Jeder sollte f\u00e4hig sein, die Tools, die t\u00e4glich genutzt werden, auch ohne oder mit einer anderen Oberfl\u00e4che, sicher zu verwenden. Genauso sollte m\u00f6gliche Probleme und Limitierungen erkannt und verstanden werden k\u00f6nnen. Nutz den (f\u00fcr Dich) passenden Editor (GCG13002) Du solltet den Editor, unabh\u00e4ngig davon, ob es eine vollwertige IDE oder ein Texteditor f\u00fcr die Konsole ist, nutzen, mit dem du am besten arbeiten kannst. Ein solches Tool sollte die Produktivit\u00e4t steigern und zu dem Workload passen. Es kann sein, dass ein Umfeld (Programmiersprache, Arbeitgeber usw.) bestimmte Tools voraussetzt. Diese sollten dann so eingerichtet werden, dass sie die eigenen Anspr\u00fcche erf\u00fcllen und nicht die von Kollegen \u2013 man selbst arbeitet \u00fcberwiegen damit, nicht der Kollege oder die Kollegin. Dazu z\u00e4hlen Shortcuts, Highlighting, Appearance and Behavior, Automatismen etc. Verwendung von CI/CD-Systemen (GCG13003) CI/CD -Systeme k\u00f6nnen alle Schritte (Bauen, Testen, Packen, Verteilen etc.) nach der eigentlichen Entwicklung automatisieren. Diese Tools beschleunigen diese Prozesse und verhindern Fehler. Im besten Fall wird die CI/CD-Pipeline automatisch mit dem Ver\u00f6ffentlichen einer \u00c4nderung ausgel\u00f6st. Ebenfalls k\u00f6nnen Tools zur \u00dcberpr\u00fcfung der Codequalit\u00e4t teil der CI/CD-Pipeline sein. Test- und Produktivversionen d\u00fcrfen nicht lokal gebaut werden (GCG13004) Um sicherzustellen, dass jeder Build reproduzierbar ist, d\u00fcrfen Test- und Produktivversionen nicht lokal gebaut werden, sondern, am besten automatisiert, nur auf einem Buildserver. Dies beschleunigt den Prozess und sorgt f\u00fcr eine erh\u00f6hte Integrit\u00e4t und Konsistenz der Build-Artefakte. Verwendung von Tools zur steigerung der Codequalit\u00e4t (GCG13005) Es gibt diverse M\u00f6glichkeiten, um die Codequalit\u00e4t pr\u00fcfen zu lassen. Die zwei, die am einfachsten zu realisieren sind, sind automatisierte Tests (besonders Unittests) und die Verwendung von Tools zur statischen Codeanalyse. Um Verbesserungen nachweisen zu k\u00f6nnen, sollten entsprechende Metriken gesammelt werden. Das Definieren eines Codestyles oder von Codingguidelienes kann genauso ein Werkzeug darstellen.","title":"Tools and Automation"},{"location":"guidelines/general/13000/#tools-und-automatismen","text":"","title":"Tools und Automatismen"},{"location":"guidelines/general/13000/#know-the-basics-gcg13001","text":"Wenn Tools \u00fcber eine Oberfl\u00e4che genutzt werden, dann sollten die dahinterstehenden Prozesse und Mechanismen in den Grundz\u00fcgen bekannt sein. Jeder sollte f\u00e4hig sein, die Tools, die t\u00e4glich genutzt werden, auch ohne oder mit einer anderen Oberfl\u00e4che, sicher zu verwenden. Genauso sollte m\u00f6gliche Probleme und Limitierungen erkannt und verstanden werden k\u00f6nnen.","title":"Know the basics (GCG13001) "},{"location":"guidelines/general/13000/#nutz-den-fur-dich-passenden-editor-gcg13002","text":"Du solltet den Editor, unabh\u00e4ngig davon, ob es eine vollwertige IDE oder ein Texteditor f\u00fcr die Konsole ist, nutzen, mit dem du am besten arbeiten kannst. Ein solches Tool sollte die Produktivit\u00e4t steigern und zu dem Workload passen. Es kann sein, dass ein Umfeld (Programmiersprache, Arbeitgeber usw.) bestimmte Tools voraussetzt. Diese sollten dann so eingerichtet werden, dass sie die eigenen Anspr\u00fcche erf\u00fcllen und nicht die von Kollegen \u2013 man selbst arbeitet \u00fcberwiegen damit, nicht der Kollege oder die Kollegin. Dazu z\u00e4hlen Shortcuts, Highlighting, Appearance and Behavior, Automatismen etc.","title":"Nutz den (f\u00fcr Dich) passenden Editor (GCG13002) "},{"location":"guidelines/general/13000/#verwendung-von-cicd-systemen-gcg13003","text":"CI/CD -Systeme k\u00f6nnen alle Schritte (Bauen, Testen, Packen, Verteilen etc.) nach der eigentlichen Entwicklung automatisieren. Diese Tools beschleunigen diese Prozesse und verhindern Fehler. Im besten Fall wird die CI/CD-Pipeline automatisch mit dem Ver\u00f6ffentlichen einer \u00c4nderung ausgel\u00f6st. Ebenfalls k\u00f6nnen Tools zur \u00dcberpr\u00fcfung der Codequalit\u00e4t teil der CI/CD-Pipeline sein.","title":"Verwendung von CI/CD-Systemen (GCG13003) "},{"location":"guidelines/general/13000/#test-und-produktivversionen-durfen-nicht-lokal-gebaut-werden-gcg13004","text":"Um sicherzustellen, dass jeder Build reproduzierbar ist, d\u00fcrfen Test- und Produktivversionen nicht lokal gebaut werden, sondern, am besten automatisiert, nur auf einem Buildserver. Dies beschleunigt den Prozess und sorgt f\u00fcr eine erh\u00f6hte Integrit\u00e4t und Konsistenz der Build-Artefakte.","title":"Test- und Produktivversionen d\u00fcrfen nicht lokal gebaut werden (GCG13004) "},{"location":"guidelines/general/13000/#verwendung-von-tools-zur-steigerung-der-codequalitat-gcg13005","text":"Es gibt diverse M\u00f6glichkeiten, um die Codequalit\u00e4t pr\u00fcfen zu lassen. Die zwei, die am einfachsten zu realisieren sind, sind automatisierte Tests (besonders Unittests) und die Verwendung von Tools zur statischen Codeanalyse. Um Verbesserungen nachweisen zu k\u00f6nnen, sollten entsprechende Metriken gesammelt werden. Das Definieren eines Codestyles oder von Codingguidelienes kann genauso ein Werkzeug darstellen.","title":"Verwendung von Tools zur steigerung der Codequalit\u00e4t (GCG13005) "},{"location":"guidelines/general/14000/","text":"en Translation coming soon Namenskonvention Verwende US English (GCG14001) Alle Identifier (Typen, Member, Parameter, Variablen etc.) sollte mit W\u00f6rtern aus dem amerikanischen Englisch gebildet werden. Die Namen sollten leicht lesbar und grammatikalisch richtig sein. Beispiel: HorizontalAlginment ist besser als AlignmentHorizontal Lesbarkeit ist wichtiger als K\u00fcrze. Beispiel: CanScrollHorizontally ist besser als ScrollableX Bei den Namen sollte auf Schl\u00fcsselw\u00f6rter aus den verbreiteten Programmiersprachen verzichtet werden. Verwende die richtige Schreibweise f\u00fcr Sprachelemente (GCG14002) Abh\u00e4ngig von der jeweiligen Sprache sollte die richtige Schreibweise f\u00fcr Sprachelemente wie z. B. Klassen, Methoden und Variablen gew\u00e4hlt werden. Die am meisten verbreiteten sind Camel Case, Pascal Case, Snake Case und Kebab Case . Verwende keine Zahlen in Variablen, Parametern und anderen Member (GCG14003) Solche Namen resultieren meisten aus Faulheit. Entweder weil man sich nicht genug Gedanken \u00fcber einen passenden Namen gemacht hat, oder man mehrere Elemente, statt einer Liste implementiert hat. Verwende keine Pr\u00e4fixe (GCG14004) Typen, Member, Parameter, Variablen etc. sollten nicht mit einem Pr\u00e4fix versehen werden, um ihren Typ oder Scope zu definieren. Bekannt sind z. B. die Pr\u00e4fixe g_ f\u00fcr global , s_ f\u00fcr static oder string , i_ f\u00fcr \u00eenteger und _ f\u00fcr private Member. Nicht in allen Sprachen ist es m\u00f6glich, diese Regel umzusetzen. In einigen Sprachen werden Backingfields mit dem Pr\u00e4fix _ versehen. In andere Sprachen ist dieses Pr\u00e4fix f\u00fcr private oder spezielle Member n\u00f6tig. Verwende keine Abk\u00fcrzungen (GCG14005) Abk\u00fcrzungen wie btn f\u00fcr Button und cmd f\u00fcr Command tragen nicht zur Lesbarkeit und Verst\u00e4ndlichkeit bei und sollten daher nicht genutzt. Ebenfalls sollten Namen vermieden werden, die nur aus einem Buchstaben bestehen, z. B. i f\u00fcr index und q f\u00fcr query . Ausnahme: es sollten nur Abk\u00fcrzungen genutzt werden, die allgemein oder in der jeweiligen Dom\u00e4ne gel\u00e4ufig sind. Benenne Member, Parameter und Variablen entsprechend ihrer Bedeutung, nicht ihres Typen (GCG14006) Der Name sollte die Funktion wiederspiegeln und nicht den dahinter stehenden Typen. Namen f\u00fcr Listen und Maps sollten den Plural verwenden. Nutze bei der Benennung von Typen Substantive, Substantiv-Phrasen oder Adjektiv-Phrasen (GCG14007) Benennung Beispiel Substantiv IComponent Substantiv-Phrase ICustomAttributeProvider Adjektiv-Phrase IPersistable Nutze bei der Benennung von Methoden Verben oder Verb-Objekt-Paare (GCG14008) Benennung Beispiel Verb Show Verb-Objekt-Paar ShowDialog Die Namen sollten ein Hinweis darauf sein, was die Methode macht. W\u00e4hle bei der Benennung von generischen Parametern aussagekr\u00e4ftige Namen (GCG14009) Pr\u00e4fixe generische Parameter mit dem Buchstaben T f\u00fcr Type . Verwende einen Namen, der die Bedeutung des \u00fcbergebenen Typen erkl\u00e4rt. W\u00e4hle Namen entsprechend anderer Member innerhalb der jeweiligen Sprache oder des jeweiligen Frameworks (GCG14010) Um einen Entwickler, der bereits mit einer Sprache oder einem Framework vertraut ist, den Einstieg in ein Projekt m\u00f6glichst leicht zu machen, sollte Namen verwendet werden, die in der jeweiligen Sprache bzw. dem jeweiligen Framework verwendet werden. Vermeide Namen, die verwechselt werden k\u00f6nnen (GCG14011) Nur weil ein Ausdruck technisch korrekt ist, muss er nicht verst\u00e4ndlich sein. bool b001 = (lo == l0) ? (I1 == 11) : (lOl != 101); Wiederhole nicht den Namen eines Typen innerhalb seiner Member (GCG14013) class Employee { // Wrong! static GetEmployee() {...} DeleteEmployee() {...} // Right static Get() {...} Delete() {...} // Also correct. AddNewJob() {...} RegisterForMeeting() {...} } Vermeide Klassennamen die W\u00f6rter wie Utility oder Helper beinhalten (GCG14013) Klassen, die W\u00f6rter wie Utility oder Helper in dem Namen haben, sind meist statisch und entstehen durch Missachten von den Regeln der objektorientierten Programmierung. Vermeide Methodennamen das Wort And beinhalten (GCG14014) Methoden, die das Wort And beinhalten, machen meist mehr als eine Sache und versto\u00dfen damit gegen das Single Responsibility Principle . Pr\u00e4fixen von booleschen Variablen und Member (GCG14015) Um die Aussagekraft von booleschen Variablen oder Member zu erh\u00f6hen, sollten diese mit den Worten is , has , can , allows oder supports versehen werden.","title":"Namming Conventions"},{"location":"guidelines/general/14000/#namenskonvention","text":"","title":"Namenskonvention"},{"location":"guidelines/general/14000/#verwende-us-english-gcg14001","text":"Alle Identifier (Typen, Member, Parameter, Variablen etc.) sollte mit W\u00f6rtern aus dem amerikanischen Englisch gebildet werden. Die Namen sollten leicht lesbar und grammatikalisch richtig sein. Beispiel: HorizontalAlginment ist besser als AlignmentHorizontal Lesbarkeit ist wichtiger als K\u00fcrze. Beispiel: CanScrollHorizontally ist besser als ScrollableX Bei den Namen sollte auf Schl\u00fcsselw\u00f6rter aus den verbreiteten Programmiersprachen verzichtet werden.","title":"Verwende US English (GCG14001) "},{"location":"guidelines/general/14000/#verwende-die-richtige-schreibweise-fur-sprachelemente-gcg14002","text":"Abh\u00e4ngig von der jeweiligen Sprache sollte die richtige Schreibweise f\u00fcr Sprachelemente wie z. B. Klassen, Methoden und Variablen gew\u00e4hlt werden. Die am meisten verbreiteten sind Camel Case, Pascal Case, Snake Case und Kebab Case .","title":"Verwende die richtige Schreibweise f\u00fcr Sprachelemente (GCG14002) "},{"location":"guidelines/general/14000/#verwende-keine-zahlen-in-variablen-parametern-und-anderen-member-gcg14003","text":"Solche Namen resultieren meisten aus Faulheit. Entweder weil man sich nicht genug Gedanken \u00fcber einen passenden Namen gemacht hat, oder man mehrere Elemente, statt einer Liste implementiert hat.","title":"Verwende keine Zahlen in Variablen, Parametern und anderen Member (GCG14003) "},{"location":"guidelines/general/14000/#verwende-keine-prafixe-gcg14004","text":"Typen, Member, Parameter, Variablen etc. sollten nicht mit einem Pr\u00e4fix versehen werden, um ihren Typ oder Scope zu definieren. Bekannt sind z. B. die Pr\u00e4fixe g_ f\u00fcr global , s_ f\u00fcr static oder string , i_ f\u00fcr \u00eenteger und _ f\u00fcr private Member. Nicht in allen Sprachen ist es m\u00f6glich, diese Regel umzusetzen. In einigen Sprachen werden Backingfields mit dem Pr\u00e4fix _ versehen. In andere Sprachen ist dieses Pr\u00e4fix f\u00fcr private oder spezielle Member n\u00f6tig.","title":"Verwende keine Pr\u00e4fixe (GCG14004) "},{"location":"guidelines/general/14000/#verwende-keine-abkurzungen-gcg14005","text":"Abk\u00fcrzungen wie btn f\u00fcr Button und cmd f\u00fcr Command tragen nicht zur Lesbarkeit und Verst\u00e4ndlichkeit bei und sollten daher nicht genutzt. Ebenfalls sollten Namen vermieden werden, die nur aus einem Buchstaben bestehen, z. B. i f\u00fcr index und q f\u00fcr query . Ausnahme: es sollten nur Abk\u00fcrzungen genutzt werden, die allgemein oder in der jeweiligen Dom\u00e4ne gel\u00e4ufig sind.","title":"Verwende keine Abk\u00fcrzungen (GCG14005) "},{"location":"guidelines/general/14000/#benenne-member-parameter-und-variablen-entsprechend-ihrer-bedeutung-nicht-ihres-typen-gcg14006","text":"Der Name sollte die Funktion wiederspiegeln und nicht den dahinter stehenden Typen. Namen f\u00fcr Listen und Maps sollten den Plural verwenden.","title":"Benenne Member, Parameter und Variablen entsprechend ihrer Bedeutung, nicht ihres Typen (GCG14006) "},{"location":"guidelines/general/14000/#nutze-bei-der-benennung-von-typen-substantive-substantiv-phrasen-oder-adjektiv-phrasen-gcg14007","text":"Benennung Beispiel Substantiv IComponent Substantiv-Phrase ICustomAttributeProvider Adjektiv-Phrase IPersistable","title":"Nutze bei der Benennung von Typen Substantive, Substantiv-Phrasen oder Adjektiv-Phrasen (GCG14007) "},{"location":"guidelines/general/14000/#nutze-bei-der-benennung-von-methoden-verben-oder-verb-objekt-paare-gcg14008","text":"Benennung Beispiel Verb Show Verb-Objekt-Paar ShowDialog Die Namen sollten ein Hinweis darauf sein, was die Methode macht.","title":"Nutze bei der Benennung von Methoden Verben oder Verb-Objekt-Paare (GCG14008) "},{"location":"guidelines/general/14000/#wahle-bei-der-benennung-von-generischen-parametern-aussagekraftige-namen-gcg14009","text":"Pr\u00e4fixe generische Parameter mit dem Buchstaben T f\u00fcr Type . Verwende einen Namen, der die Bedeutung des \u00fcbergebenen Typen erkl\u00e4rt.","title":"W\u00e4hle bei der Benennung von generischen Parametern aussagekr\u00e4ftige Namen (GCG14009) "},{"location":"guidelines/general/14000/#wahle-namen-entsprechend-anderer-member-innerhalb-der-jeweiligen-sprache-oder-des-jeweiligen-frameworks-gcg14010","text":"Um einen Entwickler, der bereits mit einer Sprache oder einem Framework vertraut ist, den Einstieg in ein Projekt m\u00f6glichst leicht zu machen, sollte Namen verwendet werden, die in der jeweiligen Sprache bzw. dem jeweiligen Framework verwendet werden.","title":"W\u00e4hle Namen entsprechend anderer Member innerhalb der jeweiligen Sprache oder des jeweiligen Frameworks (GCG14010) "},{"location":"guidelines/general/14000/#vermeide-namen-die-verwechselt-werden-konnen-gcg14011","text":"Nur weil ein Ausdruck technisch korrekt ist, muss er nicht verst\u00e4ndlich sein. bool b001 = (lo == l0) ? (I1 == 11) : (lOl != 101);","title":"Vermeide Namen, die verwechselt werden k\u00f6nnen (GCG14011) "},{"location":"guidelines/general/14000/#wiederhole-nicht-den-namen-eines-typen-innerhalb-seiner-member-gcg14013","text":"class Employee { // Wrong! static GetEmployee() {...} DeleteEmployee() {...} // Right static Get() {...} Delete() {...} // Also correct. AddNewJob() {...} RegisterForMeeting() {...} }","title":"Wiederhole nicht den Namen eines Typen innerhalb seiner Member (GCG14013) "},{"location":"guidelines/general/14000/#vermeide-klassennamen-die-worter-wie-utility-oder-helper-beinhalten-gcg14013","text":"Klassen, die W\u00f6rter wie Utility oder Helper in dem Namen haben, sind meist statisch und entstehen durch Missachten von den Regeln der objektorientierten Programmierung.","title":"Vermeide Klassennamen die W\u00f6rter wie Utility oder Helper beinhalten (GCG14013) "},{"location":"guidelines/general/14000/#vermeide-methodennamen-das-wort-and-beinhalten-gcg14014","text":"Methoden, die das Wort And beinhalten, machen meist mehr als eine Sache und versto\u00dfen damit gegen das Single Responsibility Principle .","title":"Vermeide Methodennamen das Wort And beinhalten (GCG14014) "},{"location":"guidelines/general/14000/#prafixen-von-booleschen-variablen-und-member-gcg14015","text":"Um die Aussagekraft von booleschen Variablen oder Member zu erh\u00f6hen, sollten diese mit den Worten is , has , can , allows oder supports versehen werden.","title":"Pr\u00e4fixen von booleschen Variablen und Member (GCG14015) "},{"location":"guidelines/general/15000/","text":"en Translation coming soon Maintainability Eine Methode sollte nicht mehr als 7 Statements haben (GCG15001) Eine Methode mit mehr als sieben Statements macht zu viel oder verst\u00f6\u00dft gegen das Single Responsibility Principle . Au\u00dferdem wird es mit jedem Statement aufw\u00e4ndiger zu verstehen, was der Code machen soll. Eine Methode mit mehr Statements sollte entsprechend in mehrere kleine Methoden, die einen selbsterkl\u00e4renden Namen haben, runtergebrochen werden. Der High-Level Algorithmus muss allerdings weiterhin verst\u00e4ndlich sein. Eine Ausnahme hierbei k\u00f6nnen Tests, Builder oder Methoden, die den Anwendungsfluss steuern sein. Es sollte dennoch gepr\u00fcft werden, ob die Anzahl der Statements pro Methode durch Pattern oder verschachtelte Pr\u00fcfungen reduziert werden k\u00f6nnen, wodurch die Verst\u00e4ndlichkeit und Wartbarkeit gesteigert werden kann. So geschlossen wie m\u00f6glich, so offen wie n\u00f6tig (GCG15002) Alle Typen und Member sollten standardm\u00e4\u00dfig nur von denen gesehen und genutzt werden k\u00f6nnen, die auf diese Typen und Member direkt zugreifen m\u00fcssen. Entsprechend sollten Member standardm\u00e4\u00dfig private und Typen internal sein. Au\u00dferdem sollten standardm\u00e4\u00dfig weder Member noch Typen \u00fcberschrieben oder beerbt werden k\u00f6nnen. Nur f\u00fcr den Fall, dass von Au\u00dfen auf einen Typen oder dessen Member zugegriffen werden muss, sollte die Sichtbarkeit langsam erh\u00f6ht werden. Vermeidung von Ausdr\u00fccken mit doppelter Negierung (GCG15003) In manchen F\u00e4llen ist es sinnvoll, oder gegeben, dass eine Variable bzw. ein Typen-Member den Negativfall abdeckt, allerdings sollte es vermieden werden, diese in einer negierten Bedingung zu verwenden. bool hasOrders = !customer.HasNoOrders; Doppelte Verneinungen sind schwerer zu verstehen und werden oft \u00fcberlesen. Ein Typ, eine Datei (GCG15004) Eine Source-Datei sollte genau einen Typen enthalten, bzw. einen Zweck dienen. Die Datei sollte auch nach diesem Typen benannt sein. Ausnahme: Nested-Types sollten Teil der Datei des \u00fcbergeordneten Typen sein. Ausnahme: Typen, die sich nur durch die Anzahl an generischen Typ-Parametern unterscheiden, sollten Teil der gleichen Datei sein. Don't use magic numbers (GCG15005) Vermeide die Verwendung von Literal Values, sowohl Zahlen als auch Strings. Stattdessen sollten Konstanten verwendet werden. Ausgenommen sind Strings f\u00fcr das Logging, sowie Werte, die durch ihren Context eindeutig sind und zuk\u00fcnftig nicht ge\u00e4ndert werden. mean = (a + b) / 2; // okay WaitMilliseconds(waitTimeInSeconds * 1000); // clear enough Anmerkung: Enum-Typen eigenen sich oft f\u00fcr Konstanten genutzt werden. Explizit, statt Implizit (GCG15006) Die Deklarierung sollte immer so explizit wie m\u00f6glich sein. Variablen sollten so sp\u00e4t wie m\u00f6glich deklariert und initialisiert werden (GCG15007) Variablen sollten zu dem Zeitpunkt deklariert und initialisiert werden, an dem sie gebraucht werden. Deklariere und Weise immer nur eine Variable pro Zeile zu (GCG15008) Vermeide Ausdr\u00fccke wie var result = otherVariable = GetSomeValue(); Keine explizite Vergleiche auf True und False (GCG15009) if (condition == false) // wrong; bad style if (condition != true) // also wrong if (((condition == true) == true) == true) // where do you stop? if (condition) // OK Ver\u00e4ndere nicht die Loop-Variable innerhalb eines for -Loops (GCG15010) Das Updaten der Loop-Variablen innerhalb des Loops f\u00fcr in aller Regel zu Verwirrung, besonders, wenn sie an mehr als einer Stelle ver\u00e4ndert wird. for (int index = 0; index < 10; index++) { if (someCondition) { index = 11; // Wrong! Use 'break' or 'continue' instead. } } Vermeide verschachtelte Loops (GCG15011) Methoden mit verschachtelten Loops ist schwerer zu verstehen, als eine Methode mit nur einem Loop. Werden verschachtelte Loops ben\u00f6tigt, sollten diese durch andere Mittel ersetzt werden, oder in mehrere Methoden aufgeteilt werden. F\u00fcge immer den default -Block nach dem letzten case in einem switch -Statement hinzu (GCG15012) Wenn der default -Block leer gelassen werden soll, dann f\u00fcge ein aussagekr\u00e4ftiges Kommentar hinzu. Wenn der Block nicht erreicht werden darf, dann wird eine Exception, um zuk\u00fcnftige \u00c4nderungen zu erkennen, die bisher nicht erwartet werden. Beende jedes if - else - if -Statement mit einem else -Statement (GCG15013) Verwende den letzten else -Block f\u00fcr das Standardverhalten. Wenn dieser Block nicht erreicht werden kann oder darf, dann wird eine Exception. Verwende ein einfaches Conditional Assignment Statement, statt einem if - else -Konstrukt (GCG15013) // rather than: bool isPositive; if (value > 0) { isPositive = true; } else { isPositive = false; } // write: bool isPositive = (value > 0); Verwende switch -Statements, statt if - else -Statement (GCG15014) In vielen F\u00e4llen kann ein switch -Statement ein if - else -Statement abl\u00f6sen und es dadurch verst\u00e4ndlicher und wartbarer gestalten. Vermeide Signaturen mit mehr als 3 Parametern (GCG15015) Um Konstruktoren, Methoden, Funktionen etc. klein und fokussiert zu halten, muss die Anzahl der Parameter gering gehalten werden. Es empfiehlt sich, die Anzahl auf drei Parameter zu beschr\u00e4nken. Konstruktoren, zum Erstellen von Typen, die mehrere Parameter erwarten, k\u00f6nnen z. B. durch das Builder-Pattern vereinfacht werden. Generell gilt, desto weniger Parameter, umso einfacher und verst\u00e4ndlicher ist die Methode. Au\u00dferdem resultiert das Testen von Methoden, die viele Parameter erwarten, in vielen Szenarien, die abgedeckt werden m\u00fcssen. Vermeide Signaturen, die einen bool -Parameter haben (GCG15016) Folgendes Beispiel: public Customer CreateCustomer(bool hasPlatinumLevel) {} Auf den ersten Blick wirkt die Signatur verst\u00e4ndlich, aber sobald die Methode verwendet wird, geht die Verst\u00e4ndlichkeit verloren: Customer customer = CreateCustomer(true); Oft macht eine Methode, die einen Boolean erwartet mehr als eine Sache. Eine Alternative ist es, den Boolean mit einer Enumeration zu ersetzen. Kommentiere niemals Code aus (GCG15017) Ver\u00f6ffentliche niemals eine \u00c4nderung, in der Code auskommentiert ist. Niemand wird wissen, weshalb der Code auskommentiert ist. Wurde es tempor\u00e4r zum Testen entfernt? Ist es ein kopiertes Beispiel? Kann der Code gel\u00f6scht werden? Schreib code, der leicht zu debuggen ist (GCG15018) Vermeide es, zu viele Statements innerhalb einer einzigen Zeile zu schreiben. Dadurch k\u00f6nnen Debugger effektiver genutzt werden. \u00dcberladungen sollten sich gegenseitig aufrufen (GCG15019) Diese Regel betrifft nur \u00dcberladungen, die optionale Parameter bereitstellen. public string ToString() { return ToString(Format.Default); } public string ToString(Format format) { return ToString(format, Culture.Default); } public string ToString(Format format, Culture culture) { // return result } Lagere komplexe Ausdr\u00fccke in separaten Methoden aus (GCG15020) Komplexe Ausdr\u00fccke, z. B. Bedingungen, sollten in Methoden mit eindeutigen Namen ausgelagert werden, damit diese verst\u00e4ndlicher werden.","title":"Maintainability"},{"location":"guidelines/general/15000/#maintainability","text":"","title":"Maintainability"},{"location":"guidelines/general/15000/#eine-methode-sollte-nicht-mehr-als-7-statements-haben-gcg15001","text":"Eine Methode mit mehr als sieben Statements macht zu viel oder verst\u00f6\u00dft gegen das Single Responsibility Principle . Au\u00dferdem wird es mit jedem Statement aufw\u00e4ndiger zu verstehen, was der Code machen soll. Eine Methode mit mehr Statements sollte entsprechend in mehrere kleine Methoden, die einen selbsterkl\u00e4renden Namen haben, runtergebrochen werden. Der High-Level Algorithmus muss allerdings weiterhin verst\u00e4ndlich sein. Eine Ausnahme hierbei k\u00f6nnen Tests, Builder oder Methoden, die den Anwendungsfluss steuern sein. Es sollte dennoch gepr\u00fcft werden, ob die Anzahl der Statements pro Methode durch Pattern oder verschachtelte Pr\u00fcfungen reduziert werden k\u00f6nnen, wodurch die Verst\u00e4ndlichkeit und Wartbarkeit gesteigert werden kann.","title":"Eine Methode sollte nicht mehr als 7 Statements haben (GCG15001) "},{"location":"guidelines/general/15000/#so-geschlossen-wie-moglich-so-offen-wie-notig-gcg15002","text":"Alle Typen und Member sollten standardm\u00e4\u00dfig nur von denen gesehen und genutzt werden k\u00f6nnen, die auf diese Typen und Member direkt zugreifen m\u00fcssen. Entsprechend sollten Member standardm\u00e4\u00dfig private und Typen internal sein. Au\u00dferdem sollten standardm\u00e4\u00dfig weder Member noch Typen \u00fcberschrieben oder beerbt werden k\u00f6nnen. Nur f\u00fcr den Fall, dass von Au\u00dfen auf einen Typen oder dessen Member zugegriffen werden muss, sollte die Sichtbarkeit langsam erh\u00f6ht werden.","title":"So geschlossen wie m\u00f6glich, so offen wie n\u00f6tig (GCG15002) "},{"location":"guidelines/general/15000/#vermeidung-von-ausdrucken-mit-doppelter-negierung-gcg15003","text":"In manchen F\u00e4llen ist es sinnvoll, oder gegeben, dass eine Variable bzw. ein Typen-Member den Negativfall abdeckt, allerdings sollte es vermieden werden, diese in einer negierten Bedingung zu verwenden. bool hasOrders = !customer.HasNoOrders; Doppelte Verneinungen sind schwerer zu verstehen und werden oft \u00fcberlesen.","title":"Vermeidung von Ausdr\u00fccken mit doppelter Negierung (GCG15003) "},{"location":"guidelines/general/15000/#ein-typ-eine-datei-gcg15004","text":"Eine Source-Datei sollte genau einen Typen enthalten, bzw. einen Zweck dienen. Die Datei sollte auch nach diesem Typen benannt sein. Ausnahme: Nested-Types sollten Teil der Datei des \u00fcbergeordneten Typen sein. Ausnahme: Typen, die sich nur durch die Anzahl an generischen Typ-Parametern unterscheiden, sollten Teil der gleichen Datei sein.","title":"Ein Typ, eine Datei (GCG15004) "},{"location":"guidelines/general/15000/#dont-use-magic-numbers-gcg15005","text":"Vermeide die Verwendung von Literal Values, sowohl Zahlen als auch Strings. Stattdessen sollten Konstanten verwendet werden. Ausgenommen sind Strings f\u00fcr das Logging, sowie Werte, die durch ihren Context eindeutig sind und zuk\u00fcnftig nicht ge\u00e4ndert werden. mean = (a + b) / 2; // okay WaitMilliseconds(waitTimeInSeconds * 1000); // clear enough Anmerkung: Enum-Typen eigenen sich oft f\u00fcr Konstanten genutzt werden.","title":"Don't use magic numbers (GCG15005) "},{"location":"guidelines/general/15000/#explizit-statt-implizit-gcg15006","text":"Die Deklarierung sollte immer so explizit wie m\u00f6glich sein.","title":"Explizit, statt Implizit (GCG15006) "},{"location":"guidelines/general/15000/#variablen-sollten-so-spat-wie-moglich-deklariert-und-initialisiert-werden-gcg15007","text":"Variablen sollten zu dem Zeitpunkt deklariert und initialisiert werden, an dem sie gebraucht werden.","title":"Variablen sollten so sp\u00e4t wie m\u00f6glich deklariert und initialisiert werden (GCG15007) "},{"location":"guidelines/general/15000/#deklariere-und-weise-immer-nur-eine-variable-pro-zeile-zu-gcg15008","text":"Vermeide Ausdr\u00fccke wie var result = otherVariable = GetSomeValue();","title":"Deklariere und Weise immer nur eine Variable pro Zeile zu (GCG15008) "},{"location":"guidelines/general/15000/#keine-explizite-vergleiche-auf-true-und-false-gcg15009","text":"if (condition == false) // wrong; bad style if (condition != true) // also wrong if (((condition == true) == true) == true) // where do you stop? if (condition) // OK","title":"Keine explizite Vergleiche auf True und False (GCG15009) "},{"location":"guidelines/general/15000/#verandere-nicht-die-loop-variable-innerhalb-eines-for-loops-gcg15010","text":"Das Updaten der Loop-Variablen innerhalb des Loops f\u00fcr in aller Regel zu Verwirrung, besonders, wenn sie an mehr als einer Stelle ver\u00e4ndert wird. for (int index = 0; index < 10; index++) { if (someCondition) { index = 11; // Wrong! Use 'break' or 'continue' instead. } }","title":"Ver\u00e4ndere nicht die Loop-Variable innerhalb eines for-Loops (GCG15010) "},{"location":"guidelines/general/15000/#vermeide-verschachtelte-loops-gcg15011","text":"Methoden mit verschachtelten Loops ist schwerer zu verstehen, als eine Methode mit nur einem Loop. Werden verschachtelte Loops ben\u00f6tigt, sollten diese durch andere Mittel ersetzt werden, oder in mehrere Methoden aufgeteilt werden.","title":"Vermeide verschachtelte Loops (GCG15011) "},{"location":"guidelines/general/15000/#fuge-immer-den-default-block-nach-dem-letzten-case-in-einem-switch-statement-hinzu-gcg15012","text":"Wenn der default -Block leer gelassen werden soll, dann f\u00fcge ein aussagekr\u00e4ftiges Kommentar hinzu. Wenn der Block nicht erreicht werden darf, dann wird eine Exception, um zuk\u00fcnftige \u00c4nderungen zu erkennen, die bisher nicht erwartet werden.","title":"F\u00fcge immer den default-Block nach dem letzten case in einem switch-Statement hinzu (GCG15012) "},{"location":"guidelines/general/15000/#beende-jedes-if-else-if-statement-mit-einem-else-statement-gcg15013","text":"Verwende den letzten else -Block f\u00fcr das Standardverhalten. Wenn dieser Block nicht erreicht werden kann oder darf, dann wird eine Exception.","title":"Beende jedes if-else-if-Statement mit einem else-Statement (GCG15013) "},{"location":"guidelines/general/15000/#verwende-ein-einfaches-conditional-assignment-statement-statt-einem-if-else-konstrukt-gcg15013","text":"// rather than: bool isPositive; if (value > 0) { isPositive = true; } else { isPositive = false; } // write: bool isPositive = (value > 0);","title":"Verwende ein einfaches Conditional Assignment Statement, statt einem if-else-Konstrukt (GCG15013) "},{"location":"guidelines/general/15000/#verwende-switch-statements-statt-if-else-statement-gcg15014","text":"In vielen F\u00e4llen kann ein switch -Statement ein if - else -Statement abl\u00f6sen und es dadurch verst\u00e4ndlicher und wartbarer gestalten.","title":"Verwende switch-Statements, statt if-else-Statement (GCG15014) "},{"location":"guidelines/general/15000/#vermeide-signaturen-mit-mehr-als-3-parametern-gcg15015","text":"Um Konstruktoren, Methoden, Funktionen etc. klein und fokussiert zu halten, muss die Anzahl der Parameter gering gehalten werden. Es empfiehlt sich, die Anzahl auf drei Parameter zu beschr\u00e4nken. Konstruktoren, zum Erstellen von Typen, die mehrere Parameter erwarten, k\u00f6nnen z. B. durch das Builder-Pattern vereinfacht werden. Generell gilt, desto weniger Parameter, umso einfacher und verst\u00e4ndlicher ist die Methode. Au\u00dferdem resultiert das Testen von Methoden, die viele Parameter erwarten, in vielen Szenarien, die abgedeckt werden m\u00fcssen.","title":"Vermeide Signaturen mit mehr als 3 Parametern (GCG15015) "},{"location":"guidelines/general/15000/#vermeide-signaturen-die-einen-bool-parameter-haben-gcg15016","text":"Folgendes Beispiel: public Customer CreateCustomer(bool hasPlatinumLevel) {} Auf den ersten Blick wirkt die Signatur verst\u00e4ndlich, aber sobald die Methode verwendet wird, geht die Verst\u00e4ndlichkeit verloren: Customer customer = CreateCustomer(true); Oft macht eine Methode, die einen Boolean erwartet mehr als eine Sache. Eine Alternative ist es, den Boolean mit einer Enumeration zu ersetzen.","title":"Vermeide Signaturen, die einen bool-Parameter haben (GCG15016) "},{"location":"guidelines/general/15000/#kommentiere-niemals-code-aus-gcg15017","text":"Ver\u00f6ffentliche niemals eine \u00c4nderung, in der Code auskommentiert ist. Niemand wird wissen, weshalb der Code auskommentiert ist. Wurde es tempor\u00e4r zum Testen entfernt? Ist es ein kopiertes Beispiel? Kann der Code gel\u00f6scht werden?","title":"Kommentiere niemals Code aus (GCG15017) "},{"location":"guidelines/general/15000/#schreib-code-der-leicht-zu-debuggen-ist-gcg15018","text":"Vermeide es, zu viele Statements innerhalb einer einzigen Zeile zu schreiben. Dadurch k\u00f6nnen Debugger effektiver genutzt werden.","title":"Schreib code, der leicht zu debuggen ist (GCG15018) "},{"location":"guidelines/general/15000/#uberladungen-sollten-sich-gegenseitig-aufrufen-gcg15019","text":"Diese Regel betrifft nur \u00dcberladungen, die optionale Parameter bereitstellen. public string ToString() { return ToString(Format.Default); } public string ToString(Format format) { return ToString(format, Culture.Default); } public string ToString(Format format, Culture culture) { // return result }","title":"\u00dcberladungen sollten sich gegenseitig aufrufen (GCG15019) "},{"location":"guidelines/general/15000/#lagere-komplexe-ausdrucke-in-separaten-methoden-aus-gcg15020","text":"Komplexe Ausdr\u00fccke, z. B. Bedingungen, sollten in Methoden mit eindeutigen Namen ausgelagert werden, damit diese verst\u00e4ndlicher werden.","title":"Lagere komplexe Ausdr\u00fccke in separaten Methoden aus (GCG15020) "},{"location":"guidelines/general/16000/","text":"en Translation coming soon Dokumentation Verwende US Englisch f\u00fcr Kommentare (CGC16001) Verwende US Englisch f\u00fcr Dokumentation (CGC16002) Dokumentiere alle von au\u00dferhalb verf\u00fcgbaren Typen und Members (CGC16003) Alle Typen und Members, die von au\u00dferhalb des Programmes, aber auch au\u00dferhalb Namespaces, Paketen oder Typen innerhalb des Programmes erreichbar sind, sollten mit, f\u00fcr die jeweilige Sprache standardisierte Style, dokumentiert werden. Auf diesen Weg k\u00f6nnen andere Entwickler den Verwendungszweck und die Verwendung verstehen, ohne den eigentlichen Code zu kennen. Au\u00dferdem ist es m\u00f6glich, mit entsprechenden Tools, eine professionell aussehende Dokumentation zu erstellen. Schreibe Dokumentation f\u00fcr andere (CGC16004) Dokumentation sollte f\u00fcr Nutzer geschrieben werden, die den dahinterstehenden Code nicht kennen. Sowohl der Verwendungszweck als auch die Verwendung sollte klar erkl\u00e4rt werden, um die bestm\u00f6gliche Verwendung sicherzustellen. Vermeide Inline-Kommentare (CGC16005) Wenn Inline-Kommentare n\u00f6tig sind, sollte es in betracht gezogen werden, ob es besser w\u00e4re, den betroffenen Code in eine eigene Methode mit einem aussagekr\u00e4ftigen Namen auszulagern. Verwende keine Kommentare, um zuk\u00fcnftige Aufgaben festzuhalten (CGC16006) Es ist gut, wenn Arbeit, die aktuell nicht erledigt werden konnte, festzuhalten, allerdings sollte dies in einem Projektmanagementsystem erfolgen. Die Verwendung von TODO -Kommentare ist zwar auch eine M\u00f6glichkeit, allerdings wird in der Praxis nicht oder nur selten nach solchen Kommentaren gesucht und gel\u00f6st. Eine weitere M\u00f6glichkeit ist eine Kombination aus beiden. Ein Ticket in dem jeweiligen Projektmanagementsystem anlegen und ein dazugeh\u00f6riges TODO -Kommentar anlegen und in diesem das Ticket referenzieren. Schreib Kommentare um komplexe Algorithmen oder Entscheidungen zu erkl\u00e4ren (CGC16007) Kommentare sollten sich auf das Was? und Warum? konzentrieren, statt auf dem Wie? . Die Statements sollten nicht Zeile f\u00fcr Zeile erkl\u00e4rt werden, sondern es sollte das Ziel erkl\u00e4rt werden, und weshalb genau diese L\u00f6sung verwendet wurde, wenn sie einer offensichtlicheren vorgezogen wurde, z. B. welche Probleme dadurch vermieden werden.","title":"Documentation"},{"location":"guidelines/general/16000/#dokumentation","text":"","title":"Dokumentation"},{"location":"guidelines/general/16000/#verwende-us-englisch-fur-kommentare-cgc16001","text":"","title":"Verwende US Englisch f\u00fcr Kommentare (CGC16001) "},{"location":"guidelines/general/16000/#verwende-us-englisch-fur-dokumentation-cgc16002","text":"","title":"Verwende US Englisch f\u00fcr Dokumentation (CGC16002) "},{"location":"guidelines/general/16000/#dokumentiere-alle-von-auerhalb-verfugbaren-typen-und-members-cgc16003","text":"Alle Typen und Members, die von au\u00dferhalb des Programmes, aber auch au\u00dferhalb Namespaces, Paketen oder Typen innerhalb des Programmes erreichbar sind, sollten mit, f\u00fcr die jeweilige Sprache standardisierte Style, dokumentiert werden. Auf diesen Weg k\u00f6nnen andere Entwickler den Verwendungszweck und die Verwendung verstehen, ohne den eigentlichen Code zu kennen. Au\u00dferdem ist es m\u00f6glich, mit entsprechenden Tools, eine professionell aussehende Dokumentation zu erstellen.","title":"Dokumentiere alle von au\u00dferhalb verf\u00fcgbaren Typen und Members (CGC16003) "},{"location":"guidelines/general/16000/#schreibe-dokumentation-fur-andere-cgc16004","text":"Dokumentation sollte f\u00fcr Nutzer geschrieben werden, die den dahinterstehenden Code nicht kennen. Sowohl der Verwendungszweck als auch die Verwendung sollte klar erkl\u00e4rt werden, um die bestm\u00f6gliche Verwendung sicherzustellen.","title":"Schreibe Dokumentation f\u00fcr andere (CGC16004) "},{"location":"guidelines/general/16000/#vermeide-inline-kommentare-cgc16005","text":"Wenn Inline-Kommentare n\u00f6tig sind, sollte es in betracht gezogen werden, ob es besser w\u00e4re, den betroffenen Code in eine eigene Methode mit einem aussagekr\u00e4ftigen Namen auszulagern.","title":"Vermeide Inline-Kommentare (CGC16005) "},{"location":"guidelines/general/16000/#verwende-keine-kommentare-um-zukunftige-aufgaben-festzuhalten-cgc16006","text":"Es ist gut, wenn Arbeit, die aktuell nicht erledigt werden konnte, festzuhalten, allerdings sollte dies in einem Projektmanagementsystem erfolgen. Die Verwendung von TODO -Kommentare ist zwar auch eine M\u00f6glichkeit, allerdings wird in der Praxis nicht oder nur selten nach solchen Kommentaren gesucht und gel\u00f6st. Eine weitere M\u00f6glichkeit ist eine Kombination aus beiden. Ein Ticket in dem jeweiligen Projektmanagementsystem anlegen und ein dazugeh\u00f6riges TODO -Kommentar anlegen und in diesem das Ticket referenzieren.","title":"Verwende keine Kommentare, um zuk\u00fcnftige Aufgaben festzuhalten (CGC16006) "},{"location":"guidelines/general/16000/#schreib-kommentare-um-komplexe-algorithmen-oder-entscheidungen-zu-erklaren-cgc16007","text":"Kommentare sollten sich auf das Was? und Warum? konzentrieren, statt auf dem Wie? . Die Statements sollten nicht Zeile f\u00fcr Zeile erkl\u00e4rt werden, sondern es sollte das Ziel erkl\u00e4rt werden, und weshalb genau diese L\u00f6sung verwendet wurde, wenn sie einer offensichtlicheren vorgezogen wurde, z. B. welche Probleme dadurch vermieden werden.","title":"Schreib Kommentare um komplexe Algorithmen oder Entscheidungen zu erkl\u00e4ren (CGC16007) "},{"location":"de/./","text":"Einleitung Was ist das? Dieses Dokument soll versuchen Richtlinien und Standards \u00fcber mehrere Programmiersprachen hinweg zu definieren. Nat\u00fcrlich muss man sich auch daran halten, was man selber predigt, weshalb aus meiner t\u00e4glichen Arbeitsweise entstanden sind und diese auch wiederspiegeln. Nicht alle Punkte sind rational zu begr\u00fcnden, einige sind einfach Entscheidungen, die ich f\u00fcr mich getroffen habe, da es mehrere richtige Weisen gibt. Am Ende spielt das allerdings alles keine Rolle, solange man sich konsistent an seine eigenen Regeln h\u00e4lt. Warum solltest Du dieses Dokument nutzen? Auch wenn manche der Meinung sind, dass Coding Guidelines unn\u00f6tiger Overhead sind oder die Kreativit\u00e4t einschr\u00e4nken, hat sich dieser Ansatz bereits \u00fcber mehrere Jahre hin bew\u00e4hrt. Das liegt daran, dass nicht jedem/jeder Entwickler: bewusst ist, dass Code in der Regel 10-mal h\u00e4ufiger gelesen als ge\u00e4ndert wird. bewusst ist, dass manche Konstrukte Probleme verursachen, selbst wenn sie in anderen Programmiersprachen gut funktionieren der Einfluss von bestimmten L\u00f6sungen in Bezug auf z. B. Sicherheit oder Performance, oder das Ignorieren solcher, bekannt ist. versteht, dass andere Entwickler eventuell nicht genug Erfahrung oder Know-How haben um elegante aber m\u00f6glicherweise abstrakte L\u00f6sungen zu verstehen. Grundlagen Selbst wenn dieses Dokument viele Punkte abdeckt, wird es nie alle m\u00f6glichen Szenarien behandeln, alleine um es nicht \u00fcberm\u00e4\u00dfig aufzubl\u00e4hen. Und entgegen der Meinung mancher (Junior) Developers, hei\u00dft es nicht, nur weil etwas nicht ausdr\u00fccklich als schlecht aufgef\u00fchrt wird, dass die Nutzung davon okay ist. Es gibt eine handvoll Regeln, die auf alle Situationen, unabh\u00e4ngig von ihrem Kontext, angewendet werden k\u00f6nnen. Dazu z\u00e4hlen folgende: Principle of least astonishment (a.k.a. POLA) : Entwickler L\u00f6sungen die jeder Versteht und erwartet. Keep it simple, stupid (a.k.a. KISS) : Die einfachste L\u00f6sung ist mehr als ausreichend. You aren't gonna need it (a.k.a. YAGIN) : Erstelle L\u00f6sungen nur f\u00fcr Probleme und Anforderungen die aktuell bestehen, nicht f\u00fcr welche, von denen Du denkst, dass sie in Zukunft gefordert werden. Kannst Du wirklich in Zukunft schauen? Don't repeat yourself (a.k.a. DRY) : Vermeide doppelten Code innerhalb einer Komponente, eines VCS Repositories oder einem bounded context , aber beachte die Regel Rule of Three . Die vier Prinzipien von Objektorientierte Programmierung : Encapsulation (Datenkapselung), Abstraction (Abstraktion), Inheritance (Vererbung) und Polymorphism (Polymorphie) Automatisch generierter Code muss in der Regel nicht den Coding Guidelines entsprechen. Wenn es dennoch m\u00f6glich ist, den Code weitestgehend den Guidelines anzupassen, dann sollte man das machen. Code, der einmalig generiert wird, sollte immer angepasst werden. Unabh\u00e4ngig davon, wie elegant etwas gel\u00f6st wurde, wenn es zu komplex f\u00fcr normale Entwickler ist, es zu ungew\u00f6hnlichen Verhalten f\u00fchrt oder es versucht zuk\u00fcnftig Probleme zu l\u00f6sen, dann ist es vermutlich die falsche L\u00f6sung und sollte neu implementiert werden. Die schlechteste Reaktion eines Entwicklers, wenn man ihn oder sie darauf aufmerksam macht, ist \u201eBut it works!\u201c. Wie fange ich an? Bitte alle Entwickler dieses Dokument einmal aufmerksam und komplett zu lesen. Damit erhalten sie ein erstes Gesp\u00fcr f\u00fcr die hier enthaltenen Regeln. Stelle sicher, dass alle mit den Regeln einverstanden sind. Erstelle eine Projekt Checklist mit den f\u00fcr euch wichtigsten Punkten, die bei jeder der Peer Review genutzt wird. \u00dcberlegt, ob ihr das Originaldokument forken wollt, um eure eigene Version zu erstellen. Nutzt Tools, z. B. IDEs, Compiler Plugins oder Buildtools, um die Guidelines einhalten zu k\u00f6nnen. Die meisten IDEs haben eine intelligente Code Inspection Engine, die, mit etwas Konfiguration, viele der Punkte abdecken kann. Inspiration Dieses Dokument ist stark von den C# Coding Guidelines beeinflusst. Bereits in den letzten Jahren habe ich regelm\u00e4\u00dfig Codesytles oder Coding Guidelines entwickelt und in meine Projekte, sowohl privat als auch beruflich, eingef\u00fchrt. Nun m\u00f6chte ich dieses Wissen nutzen, um etwas allgemein g\u00fcltiges zu schreiben und der Masse zur Verf\u00fcgung zu stellen. Handelt es sich hierbei um einen Standard? Nein! Es wird nicht erwartet, dass sich jedes Projekt an diesem Dokument orientiert. Es soll eine Hilfestellung f\u00fcr jeden sein, der sich nicht selbst damit besch\u00e4ftigen m\u00f6chte, aber dennoch innerhalb eines Teams, aber auch \u00fcber mehrere Teams hinweg, eine homogene Developerexperience haben m\u00f6chte. Um bei Entscheidungen zu helfen, welche Regeln wie wichtig sein k\u00f6nnen, habe ich den Guidelines ein Empfehlungslevel beigef\u00fcgt: Guidelines, die Du in allen Situationen anwenden solltest. Dringend empfohlene Guidelines. M\u00f6glicherweise nicht in allen Situationen anwendbar.","title":"Einleitung"},{"location":"de/./#einleitung","text":"","title":"Einleitung"},{"location":"de/./#was-ist-das","text":"Dieses Dokument soll versuchen Richtlinien und Standards \u00fcber mehrere Programmiersprachen hinweg zu definieren. Nat\u00fcrlich muss man sich auch daran halten, was man selber predigt, weshalb aus meiner t\u00e4glichen Arbeitsweise entstanden sind und diese auch wiederspiegeln. Nicht alle Punkte sind rational zu begr\u00fcnden, einige sind einfach Entscheidungen, die ich f\u00fcr mich getroffen habe, da es mehrere richtige Weisen gibt. Am Ende spielt das allerdings alles keine Rolle, solange man sich konsistent an seine eigenen Regeln h\u00e4lt.","title":"Was ist das?"},{"location":"de/./#warum-solltest-du-dieses-dokument-nutzen","text":"Auch wenn manche der Meinung sind, dass Coding Guidelines unn\u00f6tiger Overhead sind oder die Kreativit\u00e4t einschr\u00e4nken, hat sich dieser Ansatz bereits \u00fcber mehrere Jahre hin bew\u00e4hrt. Das liegt daran, dass nicht jedem/jeder Entwickler: bewusst ist, dass Code in der Regel 10-mal h\u00e4ufiger gelesen als ge\u00e4ndert wird. bewusst ist, dass manche Konstrukte Probleme verursachen, selbst wenn sie in anderen Programmiersprachen gut funktionieren der Einfluss von bestimmten L\u00f6sungen in Bezug auf z. B. Sicherheit oder Performance, oder das Ignorieren solcher, bekannt ist. versteht, dass andere Entwickler eventuell nicht genug Erfahrung oder Know-How haben um elegante aber m\u00f6glicherweise abstrakte L\u00f6sungen zu verstehen.","title":"Warum solltest Du dieses Dokument nutzen?"},{"location":"de/./#grundlagen","text":"Selbst wenn dieses Dokument viele Punkte abdeckt, wird es nie alle m\u00f6glichen Szenarien behandeln, alleine um es nicht \u00fcberm\u00e4\u00dfig aufzubl\u00e4hen. Und entgegen der Meinung mancher (Junior) Developers, hei\u00dft es nicht, nur weil etwas nicht ausdr\u00fccklich als schlecht aufgef\u00fchrt wird, dass die Nutzung davon okay ist. Es gibt eine handvoll Regeln, die auf alle Situationen, unabh\u00e4ngig von ihrem Kontext, angewendet werden k\u00f6nnen. Dazu z\u00e4hlen folgende: Principle of least astonishment (a.k.a. POLA) : Entwickler L\u00f6sungen die jeder Versteht und erwartet. Keep it simple, stupid (a.k.a. KISS) : Die einfachste L\u00f6sung ist mehr als ausreichend. You aren't gonna need it (a.k.a. YAGIN) : Erstelle L\u00f6sungen nur f\u00fcr Probleme und Anforderungen die aktuell bestehen, nicht f\u00fcr welche, von denen Du denkst, dass sie in Zukunft gefordert werden. Kannst Du wirklich in Zukunft schauen? Don't repeat yourself (a.k.a. DRY) : Vermeide doppelten Code innerhalb einer Komponente, eines VCS Repositories oder einem bounded context , aber beachte die Regel Rule of Three . Die vier Prinzipien von Objektorientierte Programmierung : Encapsulation (Datenkapselung), Abstraction (Abstraktion), Inheritance (Vererbung) und Polymorphism (Polymorphie) Automatisch generierter Code muss in der Regel nicht den Coding Guidelines entsprechen. Wenn es dennoch m\u00f6glich ist, den Code weitestgehend den Guidelines anzupassen, dann sollte man das machen. Code, der einmalig generiert wird, sollte immer angepasst werden. Unabh\u00e4ngig davon, wie elegant etwas gel\u00f6st wurde, wenn es zu komplex f\u00fcr normale Entwickler ist, es zu ungew\u00f6hnlichen Verhalten f\u00fchrt oder es versucht zuk\u00fcnftig Probleme zu l\u00f6sen, dann ist es vermutlich die falsche L\u00f6sung und sollte neu implementiert werden. Die schlechteste Reaktion eines Entwicklers, wenn man ihn oder sie darauf aufmerksam macht, ist \u201eBut it works!\u201c.","title":"Grundlagen"},{"location":"de/./#wie-fange-ich-an","text":"Bitte alle Entwickler dieses Dokument einmal aufmerksam und komplett zu lesen. Damit erhalten sie ein erstes Gesp\u00fcr f\u00fcr die hier enthaltenen Regeln. Stelle sicher, dass alle mit den Regeln einverstanden sind. Erstelle eine Projekt Checklist mit den f\u00fcr euch wichtigsten Punkten, die bei jeder der Peer Review genutzt wird. \u00dcberlegt, ob ihr das Originaldokument forken wollt, um eure eigene Version zu erstellen. Nutzt Tools, z. B. IDEs, Compiler Plugins oder Buildtools, um die Guidelines einhalten zu k\u00f6nnen. Die meisten IDEs haben eine intelligente Code Inspection Engine, die, mit etwas Konfiguration, viele der Punkte abdecken kann.","title":"Wie fange ich an?"},{"location":"de/./#inspiration","text":"Dieses Dokument ist stark von den C# Coding Guidelines beeinflusst. Bereits in den letzten Jahren habe ich regelm\u00e4\u00dfig Codesytles oder Coding Guidelines entwickelt und in meine Projekte, sowohl privat als auch beruflich, eingef\u00fchrt. Nun m\u00f6chte ich dieses Wissen nutzen, um etwas allgemein g\u00fcltiges zu schreiben und der Masse zur Verf\u00fcgung zu stellen.","title":"Inspiration"},{"location":"de/./#handelt-es-sich-hierbei-um-einen-standard","text":"Nein! Es wird nicht erwartet, dass sich jedes Projekt an diesem Dokument orientiert. Es soll eine Hilfestellung f\u00fcr jeden sein, der sich nicht selbst damit besch\u00e4ftigen m\u00f6chte, aber dennoch innerhalb eines Teams, aber auch \u00fcber mehrere Teams hinweg, eine homogene Developerexperience haben m\u00f6chte. Um bei Entscheidungen zu helfen, welche Regeln wie wichtig sein k\u00f6nnen, habe ich den Guidelines ein Empfehlungslevel beigef\u00fcgt: Guidelines, die Du in allen Situationen anwenden solltest. Dringend empfohlene Guidelines. M\u00f6glicherweise nicht in allen Situationen anwendbar.","title":"Handelt es sich hierbei um einen Standard?"},{"location":"de/guidelines/general/11000/","text":"Version Control System (VCS) Immer ein VCS nutzen (GCG11001) Es sollte f\u00fcr jedes Projekt, auch f\u00fcr sehr kleine Skripte, eine VCS genutzt werden. Bei Projekten, die von mehr als einer Person genutzt werden, sollte das Projekt auf einem Remoteserver hinterlegt sein. Die Verwendung eines VCS erlaubt es einen, auf eine sehr einfache und sichere Art und Weise, alle \u00c4nderungen nachvollziehen zu k\u00f6nnen und ungewollte \u00c4nderungen wieder r\u00fcckg\u00e4ngig zu machen. Definieren eines Workflow / einer Branching-Strategie (GCG11002) Damit jeder wei\u00df, wie mit dem verwendeten VCS zu arbeiten ist, sollte im Vorfeld ein Workflow bzw. eine Branching-Strategie definiert werden, die zu dem jeweiligen Projekt passt. Eine Branching-Strategie umfasst die Fragen Wie werden Branches benannt? Wann und wie wird ein neuer Branch erstellt? Wann und wie wird ein Branch gemerged? Wie lange leben Branches? Wie werden \u00fcber das Branching die Versionen abgebildet? Wie bei (fast) jedem Thema in der Softwareentwicklung sollte man nicht das Rad neu erfinden, sondern sich erstmal bestehende L\u00f6sungen anschauen. F\u00fcr das VCS git haben bereits viele schlaue K\u00f6pfe sich Gedanken gemacht und u. A. die Workflows Gitflow , GitLab Flow und GitHub flow entwickelt. Diese k\u00f6nnen entweder direkt \u00fcbernommen werden, oder f\u00fcr die eigene Situation angepasst und kombiniert werden. Peer Review (GCG11003) Bevor \u00c4nderungen produktiv genutzt werden, sollte mindestens eine zweite Person diese \u00fcberpr\u00fcfen. Damit kann der Code sowohl technisch als auch fachlich gepr\u00fcft werden, um die Qualit\u00e4t der \u00c4nderung sicherzustellen. Der perfekte Moment um \u00c4nderungen zu hinterfragen, Alternativen vorzuschlagen und m\u00f6gliche Fehler fr\u00fchzeitig zu erkennen.","title":"Version Control"},{"location":"de/guidelines/general/11000/#version-control-system-vcs","text":"","title":"Version Control System (VCS)"},{"location":"de/guidelines/general/11000/#immer-ein-vcs-nutzen-gcg11001","text":"Es sollte f\u00fcr jedes Projekt, auch f\u00fcr sehr kleine Skripte, eine VCS genutzt werden. Bei Projekten, die von mehr als einer Person genutzt werden, sollte das Projekt auf einem Remoteserver hinterlegt sein. Die Verwendung eines VCS erlaubt es einen, auf eine sehr einfache und sichere Art und Weise, alle \u00c4nderungen nachvollziehen zu k\u00f6nnen und ungewollte \u00c4nderungen wieder r\u00fcckg\u00e4ngig zu machen.","title":"Immer ein VCS nutzen (GCG11001) "},{"location":"de/guidelines/general/11000/#definieren-eines-workflow-einer-branching-strategie-gcg11002","text":"Damit jeder wei\u00df, wie mit dem verwendeten VCS zu arbeiten ist, sollte im Vorfeld ein Workflow bzw. eine Branching-Strategie definiert werden, die zu dem jeweiligen Projekt passt. Eine Branching-Strategie umfasst die Fragen Wie werden Branches benannt? Wann und wie wird ein neuer Branch erstellt? Wann und wie wird ein Branch gemerged? Wie lange leben Branches? Wie werden \u00fcber das Branching die Versionen abgebildet? Wie bei (fast) jedem Thema in der Softwareentwicklung sollte man nicht das Rad neu erfinden, sondern sich erstmal bestehende L\u00f6sungen anschauen. F\u00fcr das VCS git haben bereits viele schlaue K\u00f6pfe sich Gedanken gemacht und u. A. die Workflows Gitflow , GitLab Flow und GitHub flow entwickelt. Diese k\u00f6nnen entweder direkt \u00fcbernommen werden, oder f\u00fcr die eigene Situation angepasst und kombiniert werden.","title":"Definieren eines Workflow / einer Branching-Strategie (GCG11002) "},{"location":"de/guidelines/general/11000/#peer-review-gcg11003","text":"Bevor \u00c4nderungen produktiv genutzt werden, sollte mindestens eine zweite Person diese \u00fcberpr\u00fcfen. Damit kann der Code sowohl technisch als auch fachlich gepr\u00fcft werden, um die Qualit\u00e4t der \u00c4nderung sicherzustellen. Der perfekte Moment um \u00c4nderungen zu hinterfragen, Alternativen vorzuschlagen und m\u00f6gliche Fehler fr\u00fchzeitig zu erkennen.","title":"Peer Review (GCG11003) "},{"location":"de/guidelines/general/12000/","text":"Update Policy Beheben von Sicherheitsl\u00fccken (GCG12001) Sicherheitsl\u00fccken, sowohl selbst produzierte, als auch welche die durch Abh\u00e4ngigkeiten hereinkommen, sollten schnellstm\u00f6glich behoben werden. Abh\u00e4ngigkeiten regelm\u00e4\u00dfig aktualisieren (GCG12002) Abh\u00e4ngigkeiten sollten vor allem aktuell gehalten werden, um nicht in die Situation zu kommen, dass die verwendete Version nicht mehr supported wird, Sicherheitsl\u00fccken und Bugs zu beheben oder Performanceverbesserungen zu erhalten. H\u00e4lt man seine Abh\u00e4ngigkeiten aktuell und m\u00f6chte ein Feature einer neueren Version verwenden, f\u00e4llt der Aufwand um einiges geringer aus. Sofern m\u00f6glich sollten LTS -Versionen verwendet werden. Version Support Policy f\u00fcr eigene Projekte definieren (GCG12003) Wenn andere Leute (sowohl Kunden als auch Kollegen) von der Software abh\u00e4ngig sind, ergibt es Sinn zu definieren, welche Version wie lange und in welchen Umfang unterst\u00fctzt wird und entsprechend Updates erh\u00e4lt. Ebenfalls ist das Thema Abw\u00e4rtskompatibilit\u00e4t f\u00fcr die betroffenen wichtig. Pflegen eines Changelogs (GCG12004) Um eine schnelle \u00dcbersicht \u00fcber alle funktionalen \u00c4nderungen, z. B. neue Funktionen, \u00c4nderungen einer API oder behobene Fehler, zu erhalten, sollte ein Changelog gepflegt werden. F\u00fcr die \u00c4nderungshistorie von konkreten Anpassungen gibt es die Historie des VCS (siehe Immer ein VCS nutzen (GCG11001) ). Software Versioning (GCG12004) Ein verst\u00e4ndliches Versionsschema hilft Leuten, die von der eigenen Software abh\u00e4ngig sind, einen schnellen Einblick zu erhalten, wie wichtig ein Update ist. \u00dcber die Versionsnummer kann ebenfalls der Zweck einer Version kommuniziert werden (Release, Prerelease, Test etc.).","title":"Update Policy"},{"location":"de/guidelines/general/12000/#update-policy","text":"","title":"Update Policy"},{"location":"de/guidelines/general/12000/#beheben-von-sicherheitslucken-gcg12001","text":"Sicherheitsl\u00fccken, sowohl selbst produzierte, als auch welche die durch Abh\u00e4ngigkeiten hereinkommen, sollten schnellstm\u00f6glich behoben werden.","title":"Beheben von Sicherheitsl\u00fccken (GCG12001) "},{"location":"de/guidelines/general/12000/#abhangigkeiten-regelmaig-aktualisieren-gcg12002","text":"Abh\u00e4ngigkeiten sollten vor allem aktuell gehalten werden, um nicht in die Situation zu kommen, dass die verwendete Version nicht mehr supported wird, Sicherheitsl\u00fccken und Bugs zu beheben oder Performanceverbesserungen zu erhalten. H\u00e4lt man seine Abh\u00e4ngigkeiten aktuell und m\u00f6chte ein Feature einer neueren Version verwenden, f\u00e4llt der Aufwand um einiges geringer aus. Sofern m\u00f6glich sollten LTS -Versionen verwendet werden.","title":"Abh\u00e4ngigkeiten regelm\u00e4\u00dfig aktualisieren (GCG12002) "},{"location":"de/guidelines/general/12000/#version-support-policy-fur-eigene-projekte-definieren-gcg12003","text":"Wenn andere Leute (sowohl Kunden als auch Kollegen) von der Software abh\u00e4ngig sind, ergibt es Sinn zu definieren, welche Version wie lange und in welchen Umfang unterst\u00fctzt wird und entsprechend Updates erh\u00e4lt. Ebenfalls ist das Thema Abw\u00e4rtskompatibilit\u00e4t f\u00fcr die betroffenen wichtig.","title":"Version Support Policy f\u00fcr eigene Projekte definieren (GCG12003) "},{"location":"de/guidelines/general/12000/#pflegen-eines-changelogs-gcg12004","text":"Um eine schnelle \u00dcbersicht \u00fcber alle funktionalen \u00c4nderungen, z. B. neue Funktionen, \u00c4nderungen einer API oder behobene Fehler, zu erhalten, sollte ein Changelog gepflegt werden. F\u00fcr die \u00c4nderungshistorie von konkreten Anpassungen gibt es die Historie des VCS (siehe Immer ein VCS nutzen (GCG11001) ).","title":"Pflegen eines Changelogs (GCG12004) "},{"location":"de/guidelines/general/12000/#software-versioning-gcg12004","text":"Ein verst\u00e4ndliches Versionsschema hilft Leuten, die von der eigenen Software abh\u00e4ngig sind, einen schnellen Einblick zu erhalten, wie wichtig ein Update ist. \u00dcber die Versionsnummer kann ebenfalls der Zweck einer Version kommuniziert werden (Release, Prerelease, Test etc.).","title":"Software Versioning (GCG12004) "},{"location":"de/guidelines/general/13000/","text":"Tools und Automatismen Know the basics (GCG13001) Wenn Tools \u00fcber eine Oberfl\u00e4che genutzt werden, dann sollten die dahinterstehenden Prozesse und Mechanismen in den Grundz\u00fcgen bekannt sein. Jeder sollte f\u00e4hig sein, die Tools, die t\u00e4glich genutzt werden, auch ohne oder mit einer anderen Oberfl\u00e4che, sicher zu verwenden. Genauso sollte m\u00f6gliche Probleme und Limitierungen erkannt und verstanden werden k\u00f6nnen. Nutz den (f\u00fcr Dich) passenden Editor (GCG13002) Du solltet den Editor, unabh\u00e4ngig davon, ob es eine vollwertige IDE oder ein Texteditor f\u00fcr die Konsole ist, nutzen, mit dem du am besten arbeiten kannst. Ein solches Tool sollte die Produktivit\u00e4t steigern und zu dem Workload passen. Es kann sein, dass ein Umfeld (Programmiersprache, Arbeitgeber usw.) bestimmte Tools voraussetzt. Diese sollten dann so eingerichtet werden, dass sie die eigenen Anspr\u00fcche erf\u00fcllen und nicht die von Kollegen \u2013 man selbst arbeitet \u00fcberwiegen damit, nicht der Kollege oder die Kollegin. Dazu z\u00e4hlen Shortcuts, Highlighting, Appearance and Behavior, Automatismen etc. Verwendung von CI/CD-Systemen (GCG13003) CI/CD -Systeme k\u00f6nnen alle Schritte (Bauen, Testen, Packen, Verteilen etc.) nach der eigentlichen Entwicklung automatisieren. Diese Tools beschleunigen diese Prozesse und verhindern Fehler. Im besten Fall wird die CI/CD-Pipeline automatisch mit dem Ver\u00f6ffentlichen einer \u00c4nderung ausgel\u00f6st. Ebenfalls k\u00f6nnen Tools zur \u00dcberpr\u00fcfung der Codequalit\u00e4t teil der CI/CD-Pipeline sein. Test- und Produktivversionen d\u00fcrfen nicht lokal gebaut werden (GCG13004) Um sicherzustellen, dass jeder Build reproduzierbar ist, d\u00fcrfen Test- und Produktivversionen nicht lokal gebaut werden, sondern, am besten automatisiert, nur auf einem Buildserver. Dies beschleunigt den Prozess und sorgt f\u00fcr eine erh\u00f6hte Integrit\u00e4t und Konsistenz der Build-Artefakte. Verwendung von Tools zur steigerung der Codequalit\u00e4t (GCG13005) Es gibt diverse M\u00f6glichkeiten, um die Codequalit\u00e4t pr\u00fcfen zu lassen. Die zwei, die am einfachsten zu realisieren sind, sind automatisierte Tests (besonders Unittests) und die Verwendung von Tools zur statischen Codeanalyse. Um Verbesserungen nachweisen zu k\u00f6nnen, sollten entsprechende Metriken gesammelt werden. Das Definieren eines Codestyles oder von Codingguidelienes kann genauso ein Werkzeug darstellen.","title":"Tools und Automatisierung"},{"location":"de/guidelines/general/13000/#tools-und-automatismen","text":"","title":"Tools und Automatismen"},{"location":"de/guidelines/general/13000/#know-the-basics-gcg13001","text":"Wenn Tools \u00fcber eine Oberfl\u00e4che genutzt werden, dann sollten die dahinterstehenden Prozesse und Mechanismen in den Grundz\u00fcgen bekannt sein. Jeder sollte f\u00e4hig sein, die Tools, die t\u00e4glich genutzt werden, auch ohne oder mit einer anderen Oberfl\u00e4che, sicher zu verwenden. Genauso sollte m\u00f6gliche Probleme und Limitierungen erkannt und verstanden werden k\u00f6nnen.","title":"Know the basics (GCG13001) "},{"location":"de/guidelines/general/13000/#nutz-den-fur-dich-passenden-editor-gcg13002","text":"Du solltet den Editor, unabh\u00e4ngig davon, ob es eine vollwertige IDE oder ein Texteditor f\u00fcr die Konsole ist, nutzen, mit dem du am besten arbeiten kannst. Ein solches Tool sollte die Produktivit\u00e4t steigern und zu dem Workload passen. Es kann sein, dass ein Umfeld (Programmiersprache, Arbeitgeber usw.) bestimmte Tools voraussetzt. Diese sollten dann so eingerichtet werden, dass sie die eigenen Anspr\u00fcche erf\u00fcllen und nicht die von Kollegen \u2013 man selbst arbeitet \u00fcberwiegen damit, nicht der Kollege oder die Kollegin. Dazu z\u00e4hlen Shortcuts, Highlighting, Appearance and Behavior, Automatismen etc.","title":"Nutz den (f\u00fcr Dich) passenden Editor (GCG13002) "},{"location":"de/guidelines/general/13000/#verwendung-von-cicd-systemen-gcg13003","text":"CI/CD -Systeme k\u00f6nnen alle Schritte (Bauen, Testen, Packen, Verteilen etc.) nach der eigentlichen Entwicklung automatisieren. Diese Tools beschleunigen diese Prozesse und verhindern Fehler. Im besten Fall wird die CI/CD-Pipeline automatisch mit dem Ver\u00f6ffentlichen einer \u00c4nderung ausgel\u00f6st. Ebenfalls k\u00f6nnen Tools zur \u00dcberpr\u00fcfung der Codequalit\u00e4t teil der CI/CD-Pipeline sein.","title":"Verwendung von CI/CD-Systemen (GCG13003) "},{"location":"de/guidelines/general/13000/#test-und-produktivversionen-durfen-nicht-lokal-gebaut-werden-gcg13004","text":"Um sicherzustellen, dass jeder Build reproduzierbar ist, d\u00fcrfen Test- und Produktivversionen nicht lokal gebaut werden, sondern, am besten automatisiert, nur auf einem Buildserver. Dies beschleunigt den Prozess und sorgt f\u00fcr eine erh\u00f6hte Integrit\u00e4t und Konsistenz der Build-Artefakte.","title":"Test- und Produktivversionen d\u00fcrfen nicht lokal gebaut werden (GCG13004) "},{"location":"de/guidelines/general/13000/#verwendung-von-tools-zur-steigerung-der-codequalitat-gcg13005","text":"Es gibt diverse M\u00f6glichkeiten, um die Codequalit\u00e4t pr\u00fcfen zu lassen. Die zwei, die am einfachsten zu realisieren sind, sind automatisierte Tests (besonders Unittests) und die Verwendung von Tools zur statischen Codeanalyse. Um Verbesserungen nachweisen zu k\u00f6nnen, sollten entsprechende Metriken gesammelt werden. Das Definieren eines Codestyles oder von Codingguidelienes kann genauso ein Werkzeug darstellen.","title":"Verwendung von Tools zur steigerung der Codequalit\u00e4t (GCG13005) "},{"location":"de/guidelines/general/14000/","text":"Namenskonvention Verwende US English (GCG14001) Alle Identifier (Typen, Member, Parameter, Variablen etc.) sollte mit W\u00f6rtern aus dem amerikanischen Englisch gebildet werden. Die Namen sollten leicht lesbar und grammatikalisch richtig sein. Beispiel: HorizontalAlginment ist besser als AlignmentHorizontal Lesbarkeit ist wichtiger als K\u00fcrze. Beispiel: CanScrollHorizontally ist besser als ScrollableX Bei den Namen sollte auf Schl\u00fcsselw\u00f6rter aus den verbreiteten Programmiersprachen verzichtet werden. Verwende die richtige Schreibweise f\u00fcr Sprachelemente (GCG14002) Abh\u00e4ngig von der jeweiligen Sprache sollte die richtige Schreibweise f\u00fcr Sprachelemente wie z. B. Klassen, Methoden und Variablen gew\u00e4hlt werden. Die am meisten verbreiteten sind Camel Case, Pascal Case, Snake Case und Kebab Case . Verwende keine Zahlen in Variablen, Parametern und anderen Member (GCG14003) Solche Namen resultieren meisten aus Faulheit. Entweder weil man sich nicht genug Gedanken \u00fcber einen passenden Namen gemacht hat, oder man mehrere Elemente, statt einer Liste implementiert hat. Verwende keine Pr\u00e4fixe (GCG14004) Typen, Member, Parameter, Variablen etc. sollten nicht mit einem Pr\u00e4fix versehen werden, um ihren Typ oder Scope zu definieren. Bekannt sind z. B. die Pr\u00e4fixe g_ f\u00fcr global , s_ f\u00fcr static oder string , i_ f\u00fcr \u00eenteger und _ f\u00fcr private Member. Nicht in allen Sprachen ist es m\u00f6glich, diese Regel umzusetzen. In einigen Sprachen werden Backingfields mit dem Pr\u00e4fix _ versehen. In andere Sprachen ist dieses Pr\u00e4fix f\u00fcr private oder spezielle Member n\u00f6tig. Verwende keine Abk\u00fcrzungen (GCG14005) Abk\u00fcrzungen wie btn f\u00fcr Button und cmd f\u00fcr Command tragen nicht zur Lesbarkeit und Verst\u00e4ndlichkeit bei und sollten daher nicht genutzt. Ebenfalls sollten Namen vermieden werden, die nur aus einem Buchstaben bestehen, z. B. i f\u00fcr index und q f\u00fcr query . Ausnahme: es sollten nur Abk\u00fcrzungen genutzt werden, die allgemein oder in der jeweiligen Dom\u00e4ne gel\u00e4ufig sind. Benenne Member, Parameter und Variablen entsprechend ihrer Bedeutung, nicht ihres Typen (GCG14006) Der Name sollte die Funktion wiederspiegeln und nicht den dahinter stehenden Typen. Namen f\u00fcr Listen und Maps sollten den Plural verwenden. Nutze bei der Benennung von Typen Substantive, Substantiv-Phrasen oder Adjektiv-Phrasen (GCG14007) Benennung Beispiel Substantiv IComponent Substantiv-Phrase ICustomAttributeProvider Adjektiv-Phrase IPersistable Nutze bei der Benennung von Methoden Verben oder Verb-Objekt-Paare (GCG14008) Benennung Beispiel Verb Show Verb-Objekt-Paar ShowDialog Die Namen sollten ein Hinweis darauf sein, was die Methode macht. W\u00e4hle bei der Benennung von generischen Parametern aussagekr\u00e4ftige Namen (GCG14009) Pr\u00e4fixe generische Parameter mit dem Buchstaben T f\u00fcr Type . Verwende einen Namen, der die Bedeutung des \u00fcbergebenen Typen erkl\u00e4rt. W\u00e4hle Namen entsprechend anderer Member innerhalb der jeweiligen Sprache oder des jeweiligen Frameworks (GCG14010) Um einen Entwickler, der bereits mit einer Sprache oder einem Framework vertraut ist, den Einstieg in ein Projekt m\u00f6glichst leicht zu machen, sollte Namen verwendet werden, die in der jeweiligen Sprache bzw. dem jeweiligen Framework verwendet werden. Vermeide Namen, die verwechselt werden k\u00f6nnen (GCG14011) Nur weil ein Ausdruck technisch korrekt ist, muss er nicht verst\u00e4ndlich sein. bool b001 = (lo == l0) ? (I1 == 11) : (lOl != 101); Wiederhole nicht den Namen eines Typen innerhalb seiner Member (GCG14013) class Employee { // Wrong! static GetEmployee() {...} DeleteEmployee() {...} // Right static Get() {...} Delete() {...} // Also correct. AddNewJob() {...} RegisterForMeeting() {...} } Vermeide Klassennamen die W\u00f6rter wie Utility oder Helper beinhalten (GCG14013) Klassen, die W\u00f6rter wie Utility oder Helper in dem Namen haben, sind meist statisch und entstehen durch Missachten von den Regeln der objektorientierten Programmierung. Vermeide Methodennamen das Wort And beinhalten (GCG14014) Methoden, die das Wort And beinhalten, machen meist mehr als eine Sache und versto\u00dfen damit gegen das Single Responsibility Principle . Pr\u00e4fixen von booleschen Variablen und Member (GCG14015) Um die Aussagekraft von booleschen Variablen oder Member zu erh\u00f6hen, sollten diese mit den Worten is , has , can , allows oder supports versehen werden.","title":"Namenskonvention"},{"location":"de/guidelines/general/14000/#namenskonvention","text":"","title":"Namenskonvention"},{"location":"de/guidelines/general/14000/#verwende-us-english-gcg14001","text":"Alle Identifier (Typen, Member, Parameter, Variablen etc.) sollte mit W\u00f6rtern aus dem amerikanischen Englisch gebildet werden. Die Namen sollten leicht lesbar und grammatikalisch richtig sein. Beispiel: HorizontalAlginment ist besser als AlignmentHorizontal Lesbarkeit ist wichtiger als K\u00fcrze. Beispiel: CanScrollHorizontally ist besser als ScrollableX Bei den Namen sollte auf Schl\u00fcsselw\u00f6rter aus den verbreiteten Programmiersprachen verzichtet werden.","title":"Verwende US English (GCG14001) "},{"location":"de/guidelines/general/14000/#verwende-die-richtige-schreibweise-fur-sprachelemente-gcg14002","text":"Abh\u00e4ngig von der jeweiligen Sprache sollte die richtige Schreibweise f\u00fcr Sprachelemente wie z. B. Klassen, Methoden und Variablen gew\u00e4hlt werden. Die am meisten verbreiteten sind Camel Case, Pascal Case, Snake Case und Kebab Case .","title":"Verwende die richtige Schreibweise f\u00fcr Sprachelemente (GCG14002) "},{"location":"de/guidelines/general/14000/#verwende-keine-zahlen-in-variablen-parametern-und-anderen-member-gcg14003","text":"Solche Namen resultieren meisten aus Faulheit. Entweder weil man sich nicht genug Gedanken \u00fcber einen passenden Namen gemacht hat, oder man mehrere Elemente, statt einer Liste implementiert hat.","title":"Verwende keine Zahlen in Variablen, Parametern und anderen Member (GCG14003) "},{"location":"de/guidelines/general/14000/#verwende-keine-prafixe-gcg14004","text":"Typen, Member, Parameter, Variablen etc. sollten nicht mit einem Pr\u00e4fix versehen werden, um ihren Typ oder Scope zu definieren. Bekannt sind z. B. die Pr\u00e4fixe g_ f\u00fcr global , s_ f\u00fcr static oder string , i_ f\u00fcr \u00eenteger und _ f\u00fcr private Member. Nicht in allen Sprachen ist es m\u00f6glich, diese Regel umzusetzen. In einigen Sprachen werden Backingfields mit dem Pr\u00e4fix _ versehen. In andere Sprachen ist dieses Pr\u00e4fix f\u00fcr private oder spezielle Member n\u00f6tig.","title":"Verwende keine Pr\u00e4fixe (GCG14004) "},{"location":"de/guidelines/general/14000/#verwende-keine-abkurzungen-gcg14005","text":"Abk\u00fcrzungen wie btn f\u00fcr Button und cmd f\u00fcr Command tragen nicht zur Lesbarkeit und Verst\u00e4ndlichkeit bei und sollten daher nicht genutzt. Ebenfalls sollten Namen vermieden werden, die nur aus einem Buchstaben bestehen, z. B. i f\u00fcr index und q f\u00fcr query . Ausnahme: es sollten nur Abk\u00fcrzungen genutzt werden, die allgemein oder in der jeweiligen Dom\u00e4ne gel\u00e4ufig sind.","title":"Verwende keine Abk\u00fcrzungen (GCG14005) "},{"location":"de/guidelines/general/14000/#benenne-member-parameter-und-variablen-entsprechend-ihrer-bedeutung-nicht-ihres-typen-gcg14006","text":"Der Name sollte die Funktion wiederspiegeln und nicht den dahinter stehenden Typen. Namen f\u00fcr Listen und Maps sollten den Plural verwenden.","title":"Benenne Member, Parameter und Variablen entsprechend ihrer Bedeutung, nicht ihres Typen (GCG14006) "},{"location":"de/guidelines/general/14000/#nutze-bei-der-benennung-von-typen-substantive-substantiv-phrasen-oder-adjektiv-phrasen-gcg14007","text":"Benennung Beispiel Substantiv IComponent Substantiv-Phrase ICustomAttributeProvider Adjektiv-Phrase IPersistable","title":"Nutze bei der Benennung von Typen Substantive, Substantiv-Phrasen oder Adjektiv-Phrasen (GCG14007) "},{"location":"de/guidelines/general/14000/#nutze-bei-der-benennung-von-methoden-verben-oder-verb-objekt-paare-gcg14008","text":"Benennung Beispiel Verb Show Verb-Objekt-Paar ShowDialog Die Namen sollten ein Hinweis darauf sein, was die Methode macht.","title":"Nutze bei der Benennung von Methoden Verben oder Verb-Objekt-Paare (GCG14008) "},{"location":"de/guidelines/general/14000/#wahle-bei-der-benennung-von-generischen-parametern-aussagekraftige-namen-gcg14009","text":"Pr\u00e4fixe generische Parameter mit dem Buchstaben T f\u00fcr Type . Verwende einen Namen, der die Bedeutung des \u00fcbergebenen Typen erkl\u00e4rt.","title":"W\u00e4hle bei der Benennung von generischen Parametern aussagekr\u00e4ftige Namen (GCG14009) "},{"location":"de/guidelines/general/14000/#wahle-namen-entsprechend-anderer-member-innerhalb-der-jeweiligen-sprache-oder-des-jeweiligen-frameworks-gcg14010","text":"Um einen Entwickler, der bereits mit einer Sprache oder einem Framework vertraut ist, den Einstieg in ein Projekt m\u00f6glichst leicht zu machen, sollte Namen verwendet werden, die in der jeweiligen Sprache bzw. dem jeweiligen Framework verwendet werden.","title":"W\u00e4hle Namen entsprechend anderer Member innerhalb der jeweiligen Sprache oder des jeweiligen Frameworks (GCG14010) "},{"location":"de/guidelines/general/14000/#vermeide-namen-die-verwechselt-werden-konnen-gcg14011","text":"Nur weil ein Ausdruck technisch korrekt ist, muss er nicht verst\u00e4ndlich sein. bool b001 = (lo == l0) ? (I1 == 11) : (lOl != 101);","title":"Vermeide Namen, die verwechselt werden k\u00f6nnen (GCG14011) "},{"location":"de/guidelines/general/14000/#wiederhole-nicht-den-namen-eines-typen-innerhalb-seiner-member-gcg14013","text":"class Employee { // Wrong! static GetEmployee() {...} DeleteEmployee() {...} // Right static Get() {...} Delete() {...} // Also correct. AddNewJob() {...} RegisterForMeeting() {...} }","title":"Wiederhole nicht den Namen eines Typen innerhalb seiner Member (GCG14013) "},{"location":"de/guidelines/general/14000/#vermeide-klassennamen-die-worter-wie-utility-oder-helper-beinhalten-gcg14013","text":"Klassen, die W\u00f6rter wie Utility oder Helper in dem Namen haben, sind meist statisch und entstehen durch Missachten von den Regeln der objektorientierten Programmierung.","title":"Vermeide Klassennamen die W\u00f6rter wie Utility oder Helper beinhalten (GCG14013) "},{"location":"de/guidelines/general/14000/#vermeide-methodennamen-das-wort-and-beinhalten-gcg14014","text":"Methoden, die das Wort And beinhalten, machen meist mehr als eine Sache und versto\u00dfen damit gegen das Single Responsibility Principle .","title":"Vermeide Methodennamen das Wort And beinhalten (GCG14014) "},{"location":"de/guidelines/general/14000/#prafixen-von-booleschen-variablen-und-member-gcg14015","text":"Um die Aussagekraft von booleschen Variablen oder Member zu erh\u00f6hen, sollten diese mit den Worten is , has , can , allows oder supports versehen werden.","title":"Pr\u00e4fixen von booleschen Variablen und Member (GCG14015) "},{"location":"de/guidelines/general/15000/","text":"Maintainability Eine Methode sollte nicht mehr als 7 Statements haben (GCG15001) Eine Methode mit mehr als sieben Statements macht zu viel oder verst\u00f6\u00dft gegen das Single Responsibility Principle . Au\u00dferdem wird es mit jedem Statement aufw\u00e4ndiger zu verstehen, was der Code machen soll. Eine Methode mit mehr Statements sollte entsprechend in mehrere kleine Methoden, die einen selbsterkl\u00e4renden Namen haben, runtergebrochen werden. Der High-Level Algorithmus muss allerdings weiterhin verst\u00e4ndlich sein. Eine Ausnahme hierbei k\u00f6nnen Tests, Builder oder Methoden, die den Anwendungsfluss steuern sein. Es sollte dennoch gepr\u00fcft werden, ob die Anzahl der Statements pro Methode durch Pattern oder verschachtelte Pr\u00fcfungen reduziert werden k\u00f6nnen, wodurch die Verst\u00e4ndlichkeit und Wartbarkeit gesteigert werden kann. So geschlossen wie m\u00f6glich, so offen wie n\u00f6tig (GCG15002) Alle Typen und Member sollten standardm\u00e4\u00dfig nur von denen gesehen und genutzt werden k\u00f6nnen, die auf diese Typen und Member direkt zugreifen m\u00fcssen. Entsprechend sollten Member standardm\u00e4\u00dfig private und Typen internal sein. Au\u00dferdem sollten standardm\u00e4\u00dfig weder Member noch Typen \u00fcberschrieben oder beerbt werden k\u00f6nnen. Nur f\u00fcr den Fall, dass von Au\u00dfen auf einen Typen oder dessen Member zugegriffen werden muss, sollte die Sichtbarkeit langsam erh\u00f6ht werden. Vermeidung von Ausdr\u00fccken mit doppelter Negierung (GCG15003) In manchen F\u00e4llen ist es sinnvoll, oder gegeben, dass eine Variable bzw. ein Typen-Member den Negativfall abdeckt, allerdings sollte es vermieden werden, diese in einer negierten Bedingung zu verwenden. bool hasOrders = !customer.HasNoOrders; Doppelte Verneinungen sind schwerer zu verstehen und werden oft \u00fcberlesen. Ein Typ, eine Datei (GCG15004) Eine Source-Datei sollte genau einen Typen enthalten, bzw. einen Zweck dienen. Die Datei sollte auch nach diesem Typen benannt sein. Ausnahme: Nested-Types sollten Teil der Datei des \u00fcbergeordneten Typen sein. Ausnahme: Typen, die sich nur durch die Anzahl an generischen Typ-Parametern unterscheiden, sollten Teil der gleichen Datei sein. Don't use magic numbers (GCG15005) Vermeide die Verwendung von Literal Values, sowohl Zahlen als auch Strings. Stattdessen sollten Konstanten verwendet werden. Ausgenommen sind Strings f\u00fcr das Logging, sowie Werte, die durch ihren Context eindeutig sind und zuk\u00fcnftig nicht ge\u00e4ndert werden. mean = (a + b) / 2; // okay WaitMilliseconds(waitTimeInSeconds * 1000); // clear enough Anmerkung: Enum-Typen eigenen sich oft f\u00fcr Konstanten genutzt werden. Explizit, statt Implizit (GCG15006) Die Deklarierung sollte immer so explizit wie m\u00f6glich sein. Variablen sollten so sp\u00e4t wie m\u00f6glich deklariert und initialisiert werden (GCG15007) Variablen sollten zu dem Zeitpunkt deklariert und initialisiert werden, an dem sie gebraucht werden. Deklariere und Weise immer nur eine Variable pro Zeile zu (GCG15008) Vermeide Ausdr\u00fccke wie var result = otherVariable = GetSomeValue(); Keine explizite Vergleiche auf True und False (GCG15009) if (condition == false) // wrong; bad style if (condition != true) // also wrong if (((condition == true) == true) == true) // where do you stop? if (condition) // OK Ver\u00e4ndere nicht die Loop-Variable innerhalb eines for -Loops (GCG15010) Das Updaten der Loop-Variablen innerhalb des Loops f\u00fcr in aller Regel zu Verwirrung, besonders, wenn sie an mehr als einer Stelle ver\u00e4ndert wird. for (int index = 0; index < 10; index++) { if (someCondition) { index = 11; // Wrong! Use 'break' or 'continue' instead. } } Vermeide verschachtelte Loops (GCG15011) Methoden mit verschachtelten Loops ist schwerer zu verstehen, als eine Methode mit nur einem Loop. Werden verschachtelte Loops ben\u00f6tigt, sollten diese durch andere Mittel ersetzt werden, oder in mehrere Methoden aufgeteilt werden. F\u00fcge immer den default -Block nach dem letzten case in einem switch -Statement hinzu (GCG15012) Wenn der default -Block leer gelassen werden soll, dann f\u00fcge ein aussagekr\u00e4ftiges Kommentar hinzu. Wenn der Block nicht erreicht werden darf, dann wird eine Exception, um zuk\u00fcnftige \u00c4nderungen zu erkennen, die bisher nicht erwartet werden. Beende jedes if - else - if -Statement mit einem else -Statement (GCG15013) Verwende den letzten else -Block f\u00fcr das Standardverhalten. Wenn dieser Block nicht erreicht werden kann oder darf, dann wird eine Exception. Verwende ein einfaches Conditional Assignment Statement, statt einem if - else -Konstrukt (GCG15013) // rather than: bool isPositive; if (value > 0) { isPositive = true; } else { isPositive = false; } // write: bool isPositive = (value > 0); Verwende switch -Statements, statt if - else -Statement (GCG15014) In vielen F\u00e4llen kann ein switch -Statement ein if - else -Statement abl\u00f6sen und es dadurch verst\u00e4ndlicher und wartbarer gestalten. Vermeide Signaturen mit mehr als 3 Parametern (GCG15015) Um Konstruktoren, Methoden, Funktionen etc. klein und fokussiert zu halten, muss die Anzahl der Parameter gering gehalten werden. Es empfiehlt sich, die Anzahl auf drei Parameter zu beschr\u00e4nken. Konstruktoren, zum Erstellen von Typen, die mehrere Parameter erwarten, k\u00f6nnen z. B. durch das Builder-Pattern vereinfacht werden. Generell gilt, desto weniger Parameter, umso einfacher und verst\u00e4ndlicher ist die Methode. Au\u00dferdem resultiert das Testen von Methoden, die viele Parameter erwarten, in vielen Szenarien, die abgedeckt werden m\u00fcssen. Vermeide Signaturen, die einen bool -Parameter haben (GCG15016) Folgendes Beispiel: public Customer CreateCustomer(bool hasPlatinumLevel) {} Auf den ersten Blick wirkt die Signatur verst\u00e4ndlich, aber sobald die Methode verwendet wird, geht die Verst\u00e4ndlichkeit verloren: Customer customer = CreateCustomer(true); Oft macht eine Methode, die einen Boolean erwartet mehr als eine Sache. Eine Alternative ist es, den Boolean mit einer Enumeration zu ersetzen. Kommentiere niemals Code aus (GCG15017) Ver\u00f6ffentliche niemals eine \u00c4nderung, in der Code auskommentiert ist. Niemand wird wissen, weshalb der Code auskommentiert ist. Wurde es tempor\u00e4r zum Testen entfernt? Ist es ein kopiertes Beispiel? Kann der Code gel\u00f6scht werden? Schreib code, der leicht zu debuggen ist (GCG15018) Vermeide es, zu viele Statements innerhalb einer einzigen Zeile zu schreiben. Dadurch k\u00f6nnen Debugger effektiver genutzt werden. \u00dcberladungen sollten sich gegenseitig aufrufen (GCG15019) Diese Regel betrifft nur \u00dcberladungen, die optionale Parameter bereitstellen. public string ToString() { return ToString(Format.Default); } public string ToString(Format format) { return ToString(format, Culture.Default); } public string ToString(Format format, Culture culture) { // return result } Lagere komplexe Ausdr\u00fccke in separaten Methoden aus (GCG15020) Komplexe Ausdr\u00fccke, z. B. Bedingungen, sollten in Methoden mit eindeutigen Namen ausgelagert werden, damit diese verst\u00e4ndlicher werden.","title":"Maintainability"},{"location":"de/guidelines/general/15000/#maintainability","text":"","title":"Maintainability"},{"location":"de/guidelines/general/15000/#eine-methode-sollte-nicht-mehr-als-7-statements-haben-gcg15001","text":"Eine Methode mit mehr als sieben Statements macht zu viel oder verst\u00f6\u00dft gegen das Single Responsibility Principle . Au\u00dferdem wird es mit jedem Statement aufw\u00e4ndiger zu verstehen, was der Code machen soll. Eine Methode mit mehr Statements sollte entsprechend in mehrere kleine Methoden, die einen selbsterkl\u00e4renden Namen haben, runtergebrochen werden. Der High-Level Algorithmus muss allerdings weiterhin verst\u00e4ndlich sein. Eine Ausnahme hierbei k\u00f6nnen Tests, Builder oder Methoden, die den Anwendungsfluss steuern sein. Es sollte dennoch gepr\u00fcft werden, ob die Anzahl der Statements pro Methode durch Pattern oder verschachtelte Pr\u00fcfungen reduziert werden k\u00f6nnen, wodurch die Verst\u00e4ndlichkeit und Wartbarkeit gesteigert werden kann.","title":"Eine Methode sollte nicht mehr als 7 Statements haben (GCG15001) "},{"location":"de/guidelines/general/15000/#so-geschlossen-wie-moglich-so-offen-wie-notig-gcg15002","text":"Alle Typen und Member sollten standardm\u00e4\u00dfig nur von denen gesehen und genutzt werden k\u00f6nnen, die auf diese Typen und Member direkt zugreifen m\u00fcssen. Entsprechend sollten Member standardm\u00e4\u00dfig private und Typen internal sein. Au\u00dferdem sollten standardm\u00e4\u00dfig weder Member noch Typen \u00fcberschrieben oder beerbt werden k\u00f6nnen. Nur f\u00fcr den Fall, dass von Au\u00dfen auf einen Typen oder dessen Member zugegriffen werden muss, sollte die Sichtbarkeit langsam erh\u00f6ht werden.","title":"So geschlossen wie m\u00f6glich, so offen wie n\u00f6tig (GCG15002) "},{"location":"de/guidelines/general/15000/#vermeidung-von-ausdrucken-mit-doppelter-negierung-gcg15003","text":"In manchen F\u00e4llen ist es sinnvoll, oder gegeben, dass eine Variable bzw. ein Typen-Member den Negativfall abdeckt, allerdings sollte es vermieden werden, diese in einer negierten Bedingung zu verwenden. bool hasOrders = !customer.HasNoOrders; Doppelte Verneinungen sind schwerer zu verstehen und werden oft \u00fcberlesen.","title":"Vermeidung von Ausdr\u00fccken mit doppelter Negierung (GCG15003) "},{"location":"de/guidelines/general/15000/#ein-typ-eine-datei-gcg15004","text":"Eine Source-Datei sollte genau einen Typen enthalten, bzw. einen Zweck dienen. Die Datei sollte auch nach diesem Typen benannt sein. Ausnahme: Nested-Types sollten Teil der Datei des \u00fcbergeordneten Typen sein. Ausnahme: Typen, die sich nur durch die Anzahl an generischen Typ-Parametern unterscheiden, sollten Teil der gleichen Datei sein.","title":"Ein Typ, eine Datei (GCG15004) "},{"location":"de/guidelines/general/15000/#dont-use-magic-numbers-gcg15005","text":"Vermeide die Verwendung von Literal Values, sowohl Zahlen als auch Strings. Stattdessen sollten Konstanten verwendet werden. Ausgenommen sind Strings f\u00fcr das Logging, sowie Werte, die durch ihren Context eindeutig sind und zuk\u00fcnftig nicht ge\u00e4ndert werden. mean = (a + b) / 2; // okay WaitMilliseconds(waitTimeInSeconds * 1000); // clear enough Anmerkung: Enum-Typen eigenen sich oft f\u00fcr Konstanten genutzt werden.","title":"Don't use magic numbers (GCG15005) "},{"location":"de/guidelines/general/15000/#explizit-statt-implizit-gcg15006","text":"Die Deklarierung sollte immer so explizit wie m\u00f6glich sein.","title":"Explizit, statt Implizit (GCG15006) "},{"location":"de/guidelines/general/15000/#variablen-sollten-so-spat-wie-moglich-deklariert-und-initialisiert-werden-gcg15007","text":"Variablen sollten zu dem Zeitpunkt deklariert und initialisiert werden, an dem sie gebraucht werden.","title":"Variablen sollten so sp\u00e4t wie m\u00f6glich deklariert und initialisiert werden (GCG15007) "},{"location":"de/guidelines/general/15000/#deklariere-und-weise-immer-nur-eine-variable-pro-zeile-zu-gcg15008","text":"Vermeide Ausdr\u00fccke wie var result = otherVariable = GetSomeValue();","title":"Deklariere und Weise immer nur eine Variable pro Zeile zu (GCG15008) "},{"location":"de/guidelines/general/15000/#keine-explizite-vergleiche-auf-true-und-false-gcg15009","text":"if (condition == false) // wrong; bad style if (condition != true) // also wrong if (((condition == true) == true) == true) // where do you stop? if (condition) // OK","title":"Keine explizite Vergleiche auf True und False (GCG15009) "},{"location":"de/guidelines/general/15000/#verandere-nicht-die-loop-variable-innerhalb-eines-for-loops-gcg15010","text":"Das Updaten der Loop-Variablen innerhalb des Loops f\u00fcr in aller Regel zu Verwirrung, besonders, wenn sie an mehr als einer Stelle ver\u00e4ndert wird. for (int index = 0; index < 10; index++) { if (someCondition) { index = 11; // Wrong! Use 'break' or 'continue' instead. } }","title":"Ver\u00e4ndere nicht die Loop-Variable innerhalb eines for-Loops (GCG15010) "},{"location":"de/guidelines/general/15000/#vermeide-verschachtelte-loops-gcg15011","text":"Methoden mit verschachtelten Loops ist schwerer zu verstehen, als eine Methode mit nur einem Loop. Werden verschachtelte Loops ben\u00f6tigt, sollten diese durch andere Mittel ersetzt werden, oder in mehrere Methoden aufgeteilt werden.","title":"Vermeide verschachtelte Loops (GCG15011) "},{"location":"de/guidelines/general/15000/#fuge-immer-den-default-block-nach-dem-letzten-case-in-einem-switch-statement-hinzu-gcg15012","text":"Wenn der default -Block leer gelassen werden soll, dann f\u00fcge ein aussagekr\u00e4ftiges Kommentar hinzu. Wenn der Block nicht erreicht werden darf, dann wird eine Exception, um zuk\u00fcnftige \u00c4nderungen zu erkennen, die bisher nicht erwartet werden.","title":"F\u00fcge immer den default-Block nach dem letzten case in einem switch-Statement hinzu (GCG15012) "},{"location":"de/guidelines/general/15000/#beende-jedes-if-else-if-statement-mit-einem-else-statement-gcg15013","text":"Verwende den letzten else -Block f\u00fcr das Standardverhalten. Wenn dieser Block nicht erreicht werden kann oder darf, dann wird eine Exception.","title":"Beende jedes if-else-if-Statement mit einem else-Statement (GCG15013) "},{"location":"de/guidelines/general/15000/#verwende-ein-einfaches-conditional-assignment-statement-statt-einem-if-else-konstrukt-gcg15013","text":"// rather than: bool isPositive; if (value > 0) { isPositive = true; } else { isPositive = false; } // write: bool isPositive = (value > 0);","title":"Verwende ein einfaches Conditional Assignment Statement, statt einem if-else-Konstrukt (GCG15013) "},{"location":"de/guidelines/general/15000/#verwende-switch-statements-statt-if-else-statement-gcg15014","text":"In vielen F\u00e4llen kann ein switch -Statement ein if - else -Statement abl\u00f6sen und es dadurch verst\u00e4ndlicher und wartbarer gestalten.","title":"Verwende switch-Statements, statt if-else-Statement (GCG15014) "},{"location":"de/guidelines/general/15000/#vermeide-signaturen-mit-mehr-als-3-parametern-gcg15015","text":"Um Konstruktoren, Methoden, Funktionen etc. klein und fokussiert zu halten, muss die Anzahl der Parameter gering gehalten werden. Es empfiehlt sich, die Anzahl auf drei Parameter zu beschr\u00e4nken. Konstruktoren, zum Erstellen von Typen, die mehrere Parameter erwarten, k\u00f6nnen z. B. durch das Builder-Pattern vereinfacht werden. Generell gilt, desto weniger Parameter, umso einfacher und verst\u00e4ndlicher ist die Methode. Au\u00dferdem resultiert das Testen von Methoden, die viele Parameter erwarten, in vielen Szenarien, die abgedeckt werden m\u00fcssen.","title":"Vermeide Signaturen mit mehr als 3 Parametern (GCG15015) "},{"location":"de/guidelines/general/15000/#vermeide-signaturen-die-einen-bool-parameter-haben-gcg15016","text":"Folgendes Beispiel: public Customer CreateCustomer(bool hasPlatinumLevel) {} Auf den ersten Blick wirkt die Signatur verst\u00e4ndlich, aber sobald die Methode verwendet wird, geht die Verst\u00e4ndlichkeit verloren: Customer customer = CreateCustomer(true); Oft macht eine Methode, die einen Boolean erwartet mehr als eine Sache. Eine Alternative ist es, den Boolean mit einer Enumeration zu ersetzen.","title":"Vermeide Signaturen, die einen bool-Parameter haben (GCG15016) "},{"location":"de/guidelines/general/15000/#kommentiere-niemals-code-aus-gcg15017","text":"Ver\u00f6ffentliche niemals eine \u00c4nderung, in der Code auskommentiert ist. Niemand wird wissen, weshalb der Code auskommentiert ist. Wurde es tempor\u00e4r zum Testen entfernt? Ist es ein kopiertes Beispiel? Kann der Code gel\u00f6scht werden?","title":"Kommentiere niemals Code aus (GCG15017) "},{"location":"de/guidelines/general/15000/#schreib-code-der-leicht-zu-debuggen-ist-gcg15018","text":"Vermeide es, zu viele Statements innerhalb einer einzigen Zeile zu schreiben. Dadurch k\u00f6nnen Debugger effektiver genutzt werden.","title":"Schreib code, der leicht zu debuggen ist (GCG15018) "},{"location":"de/guidelines/general/15000/#uberladungen-sollten-sich-gegenseitig-aufrufen-gcg15019","text":"Diese Regel betrifft nur \u00dcberladungen, die optionale Parameter bereitstellen. public string ToString() { return ToString(Format.Default); } public string ToString(Format format) { return ToString(format, Culture.Default); } public string ToString(Format format, Culture culture) { // return result }","title":"\u00dcberladungen sollten sich gegenseitig aufrufen (GCG15019) "},{"location":"de/guidelines/general/15000/#lagere-komplexe-ausdrucke-in-separaten-methoden-aus-gcg15020","text":"Komplexe Ausdr\u00fccke, z. B. Bedingungen, sollten in Methoden mit eindeutigen Namen ausgelagert werden, damit diese verst\u00e4ndlicher werden.","title":"Lagere komplexe Ausdr\u00fccke in separaten Methoden aus (GCG15020) "},{"location":"de/guidelines/general/16000/","text":"Dokumentation Verwende US Englisch f\u00fcr Kommentare (CGC16001) Verwende US Englisch f\u00fcr Dokumentation (CGC16002) Dokumentiere alle von au\u00dferhalb verf\u00fcgbaren Typen und Members (CGC16003) Alle Typen und Members, die von au\u00dferhalb des Programmes, aber auch au\u00dferhalb Namespaces, Paketen oder Typen innerhalb des Programmes erreichbar sind, sollten mit, f\u00fcr die jeweilige Sprache standardisierte Style, dokumentiert werden. Auf diesen Weg k\u00f6nnen andere Entwickler den Verwendungszweck und die Verwendung verstehen, ohne den eigentlichen Code zu kennen. Au\u00dferdem ist es m\u00f6glich, mit entsprechenden Tools, eine professionell aussehende Dokumentation zu erstellen. Schreibe Dokumentation f\u00fcr andere (CGC16004) Dokumentation sollte f\u00fcr Nutzer geschrieben werden, die den dahinterstehenden Code nicht kennen. Sowohl der Verwendungszweck als auch die Verwendung sollte klar erkl\u00e4rt werden, um die bestm\u00f6gliche Verwendung sicherzustellen. Vermeide Inline-Kommentare (CGC16005) Wenn Inline-Kommentare n\u00f6tig sind, sollte es in betracht gezogen werden, ob es besser w\u00e4re, den betroffenen Code in eine eigene Methode mit einem aussagekr\u00e4ftigen Namen auszulagern. Verwende keine Kommentare, um zuk\u00fcnftige Aufgaben festzuhalten (CGC16006) Es ist gut, wenn Arbeit, die aktuell nicht erledigt werden konnte, festzuhalten, allerdings sollte dies in einem Projektmanagementsystem erfolgen. Die Verwendung von TODO -Kommentare ist zwar auch eine M\u00f6glichkeit, allerdings wird in der Praxis nicht oder nur selten nach solchen Kommentaren gesucht und gel\u00f6st. Eine weitere M\u00f6glichkeit ist eine Kombination aus beiden. Ein Ticket in dem jeweiligen Projektmanagementsystem anlegen und ein dazugeh\u00f6riges TODO -Kommentar anlegen und in diesem das Ticket referenzieren. Schreib Kommentare um komplexe Algorithmen oder Entscheidungen zu erkl\u00e4ren (CGC16007) Kommentare sollten sich auf das Was? und Warum? konzentrieren, statt auf dem Wie? . Die Statements sollten nicht Zeile f\u00fcr Zeile erkl\u00e4rt werden, sondern es sollte das Ziel erkl\u00e4rt werden, und weshalb genau diese L\u00f6sung verwendet wurde, wenn sie einer offensichtlicheren vorgezogen wurde, z. B. welche Probleme dadurch vermieden werden.","title":"Dokumentation"},{"location":"de/guidelines/general/16000/#dokumentation","text":"","title":"Dokumentation"},{"location":"de/guidelines/general/16000/#verwende-us-englisch-fur-kommentare-cgc16001","text":"","title":"Verwende US Englisch f\u00fcr Kommentare (CGC16001) "},{"location":"de/guidelines/general/16000/#verwende-us-englisch-fur-dokumentation-cgc16002","text":"","title":"Verwende US Englisch f\u00fcr Dokumentation (CGC16002) "},{"location":"de/guidelines/general/16000/#dokumentiere-alle-von-auerhalb-verfugbaren-typen-und-members-cgc16003","text":"Alle Typen und Members, die von au\u00dferhalb des Programmes, aber auch au\u00dferhalb Namespaces, Paketen oder Typen innerhalb des Programmes erreichbar sind, sollten mit, f\u00fcr die jeweilige Sprache standardisierte Style, dokumentiert werden. Auf diesen Weg k\u00f6nnen andere Entwickler den Verwendungszweck und die Verwendung verstehen, ohne den eigentlichen Code zu kennen. Au\u00dferdem ist es m\u00f6glich, mit entsprechenden Tools, eine professionell aussehende Dokumentation zu erstellen.","title":"Dokumentiere alle von au\u00dferhalb verf\u00fcgbaren Typen und Members (CGC16003) "},{"location":"de/guidelines/general/16000/#schreibe-dokumentation-fur-andere-cgc16004","text":"Dokumentation sollte f\u00fcr Nutzer geschrieben werden, die den dahinterstehenden Code nicht kennen. Sowohl der Verwendungszweck als auch die Verwendung sollte klar erkl\u00e4rt werden, um die bestm\u00f6gliche Verwendung sicherzustellen.","title":"Schreibe Dokumentation f\u00fcr andere (CGC16004) "},{"location":"de/guidelines/general/16000/#vermeide-inline-kommentare-cgc16005","text":"Wenn Inline-Kommentare n\u00f6tig sind, sollte es in betracht gezogen werden, ob es besser w\u00e4re, den betroffenen Code in eine eigene Methode mit einem aussagekr\u00e4ftigen Namen auszulagern.","title":"Vermeide Inline-Kommentare (CGC16005) "},{"location":"de/guidelines/general/16000/#verwende-keine-kommentare-um-zukunftige-aufgaben-festzuhalten-cgc16006","text":"Es ist gut, wenn Arbeit, die aktuell nicht erledigt werden konnte, festzuhalten, allerdings sollte dies in einem Projektmanagementsystem erfolgen. Die Verwendung von TODO -Kommentare ist zwar auch eine M\u00f6glichkeit, allerdings wird in der Praxis nicht oder nur selten nach solchen Kommentaren gesucht und gel\u00f6st. Eine weitere M\u00f6glichkeit ist eine Kombination aus beiden. Ein Ticket in dem jeweiligen Projektmanagementsystem anlegen und ein dazugeh\u00f6riges TODO -Kommentar anlegen und in diesem das Ticket referenzieren.","title":"Verwende keine Kommentare, um zuk\u00fcnftige Aufgaben festzuhalten (CGC16006) "},{"location":"de/guidelines/general/16000/#schreib-kommentare-um-komplexe-algorithmen-oder-entscheidungen-zu-erklaren-cgc16007","text":"Kommentare sollten sich auf das Was? und Warum? konzentrieren, statt auf dem Wie? . Die Statements sollten nicht Zeile f\u00fcr Zeile erkl\u00e4rt werden, sondern es sollte das Ziel erkl\u00e4rt werden, und weshalb genau diese L\u00f6sung verwendet wurde, wenn sie einer offensichtlicheren vorgezogen wurde, z. B. welche Probleme dadurch vermieden werden.","title":"Schreib Kommentare um komplexe Algorithmen oder Entscheidungen zu erkl\u00e4ren (CGC16007) "}]}